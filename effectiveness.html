<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Attack Effectiveness</title>
		<meta name="author" content="Eric Cole">
		<meta name="version" content="0.2">
		<meta name="keywords" content="dnd,5e,dungeons,dragons,attack,effectiveness">
		<meta name="description" content="Compute Effectiveness of Attacks">
		<link rel="stylesheet" href="main.css">
		<style>
			input.toggle:not(:checked) + label + table.toggled { display:none; }
			table#attack-examples td:nth-child(2) { white-space:nowrap; }
			table#attack-examples td:nth-child(3) { font-size:60%; }
		</style>
		<script src="dnd.js"></script>
		
		<script lang="javascript">
			var damageTypes = ['all', 'acid', 'bludgeoning', 'cold', 'force', 'fire', 'magic', 'necrotic', 'piercing', 'poison', 'psychic', 'radiant', 'slashing', 'thunder']
			var damageTypeMap = {
				'':'all',
				'a':'acid',
				'b':'bludgeoning',
				'bd':'bludgeoning',
				'c':'cold',
				'e':'force',
				'fe':'force',
				'f':'fire',
				'fi':'fire',
				'm':'magic', // magic weapon damage distinct from non magical bludgeoning, piercing, and slashing weapon damage
				'n':'necrotic',
				'p':'piercing',
				'pi':'piercing',
				'q':'poison',
				'po':'poison',
				'r':'radiant',
				's':'slashing',
				'sl':'slashing',
				't':'thunder',
				'y':'psychic',
				'py':'psychic'
			};
			
			function factorial(n) {
				var result = 1.0
				
				for ( var i = 2 ; i <= n ; ++i ) { result *= i }
				
				return result
			}
			
			function repeat(count, value) {
				var r = []
				
				for ( var i = 0 ; i < count ; ++i ) { r[i] = value }
				
				return r
			}
			
			function multiply(a, b) {
				var p = []
				var i, j
				
				for ( i = 0 ; i < a.length ; ++i ) {
					for ( j = 0 ; j < b.length ; ++j ) {
						p[i + j] = a[i] * b[j] + (p[i + j] || 0)
					}
				}
				
				return p
			}
			
			function power(a, n) {
				if ( !(n > 1 && a.length > 0) ) { return a }
				if ( !(a.length > 1) ) { return [Math.pow(a[0], n)] }
				
				var b = [1]
				
				while ( n > 1 ) {
					if ( n & 1 ) {
						b = multiply(b, a)
					}
					
					n = n >> 1
					a = multiply(a, a)
				}
				
				return b.length > 1 ? multiply(b, a) : a
			}
			
			function binomialcoefficients(n) {
				var result = [1]
				if ( !( n > 0 ) ) { return result }
				
				var i, d = 1.0, c = n, k = n
				
				for ( i = 1 ; i < k ; ++i ) {
					result.push(c)
					c = c * --n / ++d
				}
				
				result.push(1)
				
				return result
			}
			
			function trinomialcoefficients(n) {
				if ( !( n > 0 ) ) { return [1] }
				
				var result = []
				var f, i, j, k, c
				
				f = 1
				
				for ( i = 0 ; i <= n ; ++i ) {
					c = f
					f = f * (n-i) / (i+1)
					
					for ( j = 0, k = n - i ; j <= n - i ; ++j, --k ) {
						if ( j ) { c = c * (k+1) / j }
						
						result[j + 2 * k] = c + (result[j + 2 * k] | 0)
					}
				}
				
				return result
			}
			
			function binomialcoefficient(n, k) {
				/*
					combinatorial number
					n choose k -- ways to choose k elements from n elements
					
					 n       n!
					( ) = --------
					 k    k!(n-k)!
				*/
				
				if ( k > 0 && k < n ) {
					if ( k > n - k ) { k = n - k } // symmetric
					
					var i, d = 1.0, c = n
					
					for ( i = 1 ; i < k ; ++i ) {
						c = c * --n / ++d
					}
					
					return c
				} else {
					return ( k < 0 || k > n ) ? 0 : 1
				}
			}
			
			function dieRoll(die) {
				return 1 + Math.floor(Math.random() * die)
			}
			
			function diceRoll(die, roll) {
				var sum = 0
				
				for ( var index = 0 ; index < roll ; ++index ) {
					sum += dieRoll(die)
				}
				
				return sum
			}
			
			function diceCombinations(die, roll) {
				/*
					diceCombinations can be combined with multiply
					
					multiply(diceCombinations(6, 2), diceCombinations(8, 2))
				*/
				
				if ( !(roll > 0 && die > 1) ) { return [1] }
				if ( !(roll > 1) ) { return repeat(die, 1) }
				if ( !(die > 2) ) { return binomialcoefficients(roll) }
				
				return power(repeat(die, 1), roll)
			}
			
			function advantageAverageForDiceCombinations(c, roll) {
				//	roll must be the total number of dice combined
				var average = 0
				var i, j, p
				var sum = 0
				
				for ( i = 0 ; i < c.length ; ++i ) {
					sum += c[i]
					p = c[i]	// both rolls are the same
					
					for ( j = 0 ; j < i ; ++j ) {
						p += 2 * c[j]	//	one roll was less
					}
					
					average += p * c[i] * (i + roll)
				}
				
				return average / (sum * sum)
			}
			
			function advantageAverageForUniformDice(die, roll, disadvantage) {
				if ( !(die > 1) ) {
					return 1
				}
				
				var average
				
				if ( roll > 1 ) {
					var c = diceCombinations(die, roll)
					
					average = advantageAverageForDiceCombinations(c, roll)
				} else {
					//	∑ k(2k-1) / n² == (n+1)(4n-1)/(6n)
					average = (die + 1)*(4*die - 1)/(6*die)
				}
				
				return disadvantage ? (roll || 1) * (die + 1) - average : average
			}
			
			function parseEffectivenessDamageType(string, result, key) {
				if ( !result[key] ) { result[key] = new Object() }
				
				var once = string.slice(-1) === 'o'
				var type = string.slice(1, once ? -1 : undefined)
				var value = once ? 'once' : true
				var index, letter, name = damageTypeMap[type]
				
				if ( name ) {
					result[key][name] = value
				} else if ( damageTypes.indexOf(type) < 0 ) {
					for ( index = 0 ; index < type.length ; ++index ) {
						letter = type.charAt(index)
						result[key][damageTypeMap[letter] || letter] = value
					}
				} else {
					result[key][type] = value
				}
			}
			
			function parseEffectiveness(string) {
				var result = new Object()
				
				result.armorClass = 10
				result.hit = []
				result.damage = []
				result.defense = []
				result.reduction = []
				string = string.toLowerCase().replace(/,•/g, " ")
				
				var match, index, found, value, roll, once, type, matched, length, item
				var beginHit = 0
				var beginDamage = string.indexOf('/', beginHit)
				var beginAttacks = string.indexOf('#', beginDamage)
				var beginDefense = string.indexOf('@', beginAttacks < 0 ? beginDamage : beginAttacks)
				var closeAttacks = beginDefense < 0 ? undefined : beginDefense
				var closeDamage = beginAttacks < 0 ? closeAttacks : beginAttacks
				var closeHit = beginDamage < 0 ? closeDamage : beginDamage
				
				var stringDefense = beginDefense < 0 ? '10' : string.slice(beginDefense + 1)
				var stringAttacks = beginAttacks < 0 ? '' : string.slice(beginAttacks + 1, closeAttacks)
				var stringDamage = beginDamage < 0 ? '' : string.slice(beginDamage + 1, closeDamage)
				var stringHit = string.slice(beginHit, closeHit)
				
				var patternHit = /([-+]\d*d?\d+o?|ao?|d[oh]?|c\d+)/g
				var matchHit = stringHit.split(patternHit)
				
				for ( index = 0 ; index < matchHit.length ; ++index ) {
					match = matchHit[index]
					
					if ( !( index & 1 ) ) {
						if ( match.trim() ) { break } else { continue }
					}
					
					if ( match === 'a' ) {
						result.advantageHit = true
					} else if ( match === 'ao' ) {
						result.advantageHit = 'once'
					} else if ( match === 'd' ) {
						if ( result.hit.length > 0 ) { break }
						result.disadvantageHit = true
					} else if ( match === 'do' ) {
						result.disadvantageHit = 'once'
					} else if ( match === 'dh' ) {
						result.disadvantageHit = 'hit'
					} else if ( match.charAt(0) === 'c' ) {
						result.criticalRoll = match.slice(1) | 0
					} else {
						found = match.indexOf('o')
						
						if ( !( found < 0 ) ) {
							once = true
							match = match.slice(0, found)
						}
						
						found = match.indexOf('d')
						
						if ( found < 0 ) {
							roll = false
							value = match | 0
						} else {
							roll = match.slice(0, found) | 0
							value = match.slice(found + 1) | 0
							if ( !roll ) { roll = match.charAt(0) === '-' ? -1 : 1 }
						}
						
						item = roll ? {'die':value, 'roll':roll} : {'modifier':value}
						if ( once ) { item.once = true }
						if ( value ) { result.hit.push(item) }
					}
				}
				
				var patternDiceModifierText = /([-+]?\d*)(d?)(\d+)([a-z]*)/
				var patternDamage = /([-+]?\d*d?\d+[a-z]*|[+]c?\d+d?|\br\d+|\bao?)/g
				var matchDamage = stringDamage.split(patternDamage)
				
				for ( index = 0 ; index < matchDamage.length ; ++index ) {
					match = matchDamage[index]
					
					if ( !( index & 1 ) ) {
						if ( match.trim() ) { break } else { continue }
					}
					
					if ( match === 'a' ) {
						result.advantageDamage = true
					} else if ( match === 'ao' ) {
						result.advantageDamage = 'once'
					} else if ( match.charAt(0) === 'r' ) {
						value = match.slice(1) | 0
						if ( value > 0 ) { result.lowDamageReroll = value }
					} else if ( match.slice(0, 2) === '+c' ) {
						found = match.indexOf('d')
						if ( found < 0 ) {
							value = match.slice(2) | 0
							result.criticalDamage = (value | 0) + (result.criticalDamage | 0)
						} else {
							value = match.slice(2, found) | 0
							result.criticalDice = (value | 0) + (result.criticalDice | 0)
						}
					} else {
						matched = match.match(patternDiceModifierText)
						type = matched[4]
						once = type.slice(-1) === 'o'
						
						if ( matched[2] === 'd' ) {
							roll = matched[1] | 0
							value = matched[3] | 0
							if ( !roll ) { roll = matched[1].charAt(0) === '-' ? -1 : 1 }
						} else {
							roll = false
							value = (matched[1] + matched[3]) | 0
						}
						
						item = roll ? {'die':value, 'roll':roll} : {'modifier':value}
						
						if ( once ) {
							item.once = true
							type = type.slice(0, -1)
						}
						
						//console.log("parseEffectivenessDamageType " + match + " => " + type + " => " + damageTypeMap[type])
						
						if ( type ) {
							item.type = damageTypeMap[type] || type
							length = result.damage.length
							
							if ( length > 0 && !roll && result.damage[length - 1].roll && !result.damage[length - 1].type ) {
								result.damage[length - 1].type = item.type
							}
						}
						
						result.damage.push(item)
					}
				}
				
				var patternAttacks = /(\d+|cb|b|r)/g
				var matchAttacks = stringAttacks.split(patternAttacks)
				
				for ( index = 0 ; index < matchAttacks.length ; ++index ) {
					match = matchAttacks[index]
					
					if ( !( index & 1 ) ) {
						if ( match.trim() ) { break } else { continue }
					}
					
					if ( match === 'cb' ) {
						result.criticalBonusAttack = true
					} else if ( match === 'b' ) {
						result.bonusAction = true
					} else if ( match === 'r' ) {
						result.reaction = true
					} else {
						value = match | 0
						if ( value > 0 ) { result.attacks = value }
					}
				}
				
				var patternDefense = /(\d+|[-+]\d*d?\d+[mo]?|v[a-z]*|r[a-z]*|i[a-z]+)/g
				var matchDefense = stringDefense.split(patternDefense)
				
				for ( index = 0 ; index < matchDefense.length ; ++index ) {
					match = matchDefense[index]
					
					if ( !( index & 1 ) ) {
						if ( match.trim() ) { break } else { continue }
					}
					
					if ( match.charAt(0) === '+' ) {
						matched = match.match(patternDiceModifierText)
						
						if ( matched[2] === 'd' ) {
							roll = matched[1] | 0
							value = matched[3] | 0
							if ( !roll ) { roll = 1 }
						} else {
							roll = false
							value = (matched[1] + matched[3]) | 0
						}
						
						item = roll ? {'die':value, 'roll':roll} : {'modifier':value}
						
						if ( matched[4] === 'o' ) { item.once = true }
						if ( matched[4] === 'm' ) { item.afterFirst = true }
						
						result.defense.push(item)
					} else if ( match.charAt(0) === '-' ) {
						matched = match.match(patternDiceModifierText)
						
						if ( matched[2] === 'd' ) {
							roll = -matched[1] | 0
							value = matched[3] | 0
							if ( !roll ) { roll = 1 }
						} else {
							roll = 0
							value = -(matched[1] + matched[3]) | 0
						}
						
						item = roll ? {'die':value, 'roll':roll} : {'modifier':value}
						
						if ( matched[4] === 'o' ) { item.once = true }
						
						result.reduction.push(item)
					} else if ( match.charAt(0) === 'v' ) {
						parseEffectivenessDamageType(match, result, 'vulnerable')
					} else if ( match.charAt(0) === 'r' ) {
						parseEffectivenessDamageType(match, result, 'resistant')
					} else if ( match.charAt(0) === 'i' ) {
						parseEffectivenessDamageType(match, result, 'immune')
					} else {
						value = match | 0
						if ( value >= 0 ) { result.armorClass = value }
					}
				}
				
				if ( !result.attacks ) {
					result.attacks = result.bonusAction || result.reaction ? 0 : 1
				}
				
				return result
			}
			
			function computeRandomEffectiveness(e) {
				var effectiveness = 0
				var asComputeAverage = e.asComputeAverage || false
				var summary = []
				var hasHit = false, hasBoosted = false, hasDefended = false
				var hasBonus = true
				var hasAdvantage, hasDisadvantage
				var attack, attacks = Math.max(+e.attacks, 1)
				var rolled, roll, die, toHit
				var modifierHit, onceModifierHit
				var armorClass, onceArmorClass, hit
				var damageRolled, damageAdvantageRolled, damageModifier
				var index, item
				var isCritical
				var advantageHit = e.advantageHit
				var disadvantageHit = e.disadvantageHit
				var advantageDamage = e.advantageDamage
				var damageDice, dieForCritical
				var damageScalar, immune, resistant, vulnerable
				
				for ( attack = 0 ; attack < attacks ; ++attack ) {
					modifierHit = 0
					onceModifierHit = 0
					
					for ( index = 0 ; index < e.hit.length ; ++index ) {
						item = e.hit[index]
						
						if ( item.once ) {
							if ( item.modifier ) { onceModifierHit += item.modifier }
							if ( item.die ) { onceModifierHit += diceRoll(item.die, item.roll || 1) }
						} else {
							if ( item.modifier ) { modifierHit += item.modifier }
							if ( item.die ) { modifierHit += diceRoll(item.die, item.roll || 1) }
						}
					}
					
					armorClass = e.armorClass || 10
					onceArmorClass = 0
					
					for ( index = 0 ; index < e.defense.length ; ++index ) {
						item = e.defense[index]
						
						if ( item.once ) {
							if ( item.modifier ) { onceArmorClass += item.modifier }
							if ( item.die ) { onceArmorClass += diceRoll(item.die, item.roll || 1) }
						} else if ( !(item.afterFirst && !hasHit) ) {
							if ( item.modifier ) { armorClass += item.modifier }
							if ( item.die ) { armorClass += diceRoll(item.die, item.roll || 1) }
						}
					}
					
					toHit = dieRoll(20)
					hasAdvantage = false
					hasDisadvantage = false
					
					if ( disadvantageHit ) {
						if ( disadvantageHit === 'once' ) { disadvantageHit = 0 }
						if ( !advantageHit ) { hasDisadvantage = true; toHit = Math.min(dieRoll(20), toHit) }
					}
					
					if ( advantageHit ) {
						if ( !hasDisadvantage ) { hasAdvantage = true; toHit = Math.max(dieRoll(20), toHit) }
						if ( advantageHit === 'once' ) { advantageHit = 0 }
					}
					
					if ( toHit < 2 ) {
						summary.push("missed AC " + armorClass + " with 1")
						continue
					}
					
					if ( toHit < 20 ) {
						hit = toHit + modifierHit - armorClass
						
						if ( !hasDefended && !(hit < 0) && hit < onceArmorClass ) {
							hasDefended = true
							armorClass += onceArmorClass
							hit -= onceArmorClass
						}
						
						if ( !hasBoosted && hit < 0 && !(hit + onceModifierHit < 0) ) {
							hasBoosted = true
							modifierHit += onceModifierHit
							hit += onceModifierHit
						}
						
						if ( !hasDefended && !(hit < 0) && hit < onceArmorClass ) {
							hasDefended = true
							armorClass += onceArmorClass
							hit -= onceArmorClass
						}
					}
					
					if ( toHit < 20 && toHit + modifierHit < armorClass ) {
						summary.push("missed AC " + armorClass + " with " + toHit + (modifierHit > 0 ? "+" + modifierHit : "") + (hasAdvantage ? " (advantage)": "") + (hasDisadvantage ? " (disadvantage)": ""))
						continue
					}
					
					if ( disadvantageHit === 'hit' ) {
						disadvantageHit = 0
					}
					
					damageRolled = 0
					damageAdvantageRolled = 0
					damageModifier = 0
					dieForCritical = 0
					damageDice = []
					
					for ( index = 0 ; index < e.damage.length ; ++index ) {
						item = e.damage[index]
						
						damageScalar = 1
						immune = e.immune && (e.immune['all'] || (item.type && e.immune[item.type]))
						resistant = e.resistant && (e.resistant['all'] || (item.type && e.resistant[item.type]))
						vulnerable = e.vulnerable && (e.vulnerable['all'] || (item.type && e.vulnerable[item.type]))
						
						if ( immune && !(hasHit && immune === 'once') ) { continue }
						if ( resistant && !(hasHit && resistant === 'once') ) { damageScalar = 0.5 }
						if ( vulnerable && !(hasHit && vulnerable === 'once') ) { damageScalar *= 2.0 }
						
						if ( !(item.once && hasHit) ) {
							if ( item.die > 0 ) { damageDice.push({'die':item.die, 'roll':item.roll, 'scalar':damageScalar}) }
							if ( item.modifier ) { damageModifier += item.modifier * damageScalar }
							if ( item.die > dieForCritical ) { dieForCritical = item.die }
						}
					}
					
					for ( index = 0 ; index < e.reduction.length ; ++index ) {
						item = e.reduction[index]
						
						if ( !(item.once && hasHit) ) {
							if ( item.die ) { damageModifier -= diceRoll(item.die, item.roll || 1) }
							if ( item.modifier ) { damageModifier -= item.modifier }
						}
					}
					
					isCritical = !(toHit < (e.criticalRoll || 20))
					
					if ( isCritical ) {
						damageDice = damageDice.concat(damageDice)
						if ( e.criticalDamage ) { damageModifier += e.criticalDamage }
						if ( e.criticalDice > 0 && dieForCritical ) { damageDice.push({'die':dieForCritical, 'roll':e.criticalDice, 'scalar':1}) }
						if ( e.criticalBonusAttack && hasBonus ) { hasBonus = false; attacks += 1 }
					}
					
					for ( index = 0 ; index < damageDice.length ; ++index ) {
						item = damageDice[index]
						damageRolled += diceRoll(item.die, item.roll || 1) * (item.scalar || 1)
						damageAdvantageRolled += diceRoll(item.die, item.roll || 1) * (item.scalar || 1)
					}
					
					hasHit = true
					
					if ( advantageDamage ) {
						damageRolled = Math.max(damageRolled, damageAdvantageRolled)
						if ( advantageDamage === 'once' ) { advantageDamage = 0 }
					}
					
					summary.push((isCritical ? "critical " : "") + "hit AC " + armorClass + " with " + toHit + (modifierHit > 0 ? "+" + modifierHit : modifierHit || "") + (hasAdvantage ? " (advantage)": "") + (hasDisadvantage ? " (disadvantage)": "") + " doing " + damageRolled + (damageModifier > 0 ? "+" + damageModifier : damageModifier || "") + " HP")
					
					effectiveness += Math.floor(damageRolled + damageModifier)
				}
				
				//console.log(summary)
				
				return effectiveness
			}
			
			function chanceToHitProduct(a, b) {
				var r = []
				
				//	1=miss, 3=near, 5=hit, 7=critical
				//	i*j%9?i*j:i*j/3 converts second near miss to true miss
				a.forEach((e, i) => b.forEach((f, j) => r[i*j%49?i*j:i*j/7] = e*f + (r[i*j%49?i*j:i*j/7] || 0)))
				
				return r
			}
			
			function chanceToHitResolveNearMisses(p) {
				var r = []
				
				/*
					AC 16
					TH +5
					OH +3
					DR +4
					
					mmmmm mmbbb dhhhh hhhhc
					
					AC 16
					TH +5
					OH +3
					DR +2
					
					mmmmm mmbbn hhhhh hhhhc
					
					m - miss
					b - miss, consumes n, b, d
					d - miss, consumes b, d
					n - hit, consumes n
					
				*/
				
				//	1=miss, 3=near, 5=hit, 7=critical, 11=block, 13=defend
				//	i%3?i:i*5/3 converts single near miss to hit
				p.forEach((e, i) => r[i%7?i:i*3/7] = e + (r[i%7?i:i*3/7] || 0))
				
				return r
			}
			
			function chanceToHitNormalize(p) {
				var n = 0
				
				p.forEach(e => n += e)
				
				return p.map(e => e / n)
			}
			
			function computeAverageEffectiveness(e) {
				var advantageDamage = e.advantageDamage
				var onceDiceDamage = 0, manyDiceDamage = 0
				var onceModifyDamage = 0, manyModifyDamage = 0
				var onceReduceDamage = 0, manyReduceDamage = 0
				var onceDice = 0, manyDice = 0
				var onceDiceCombination = [1], manyDiceCombination = [1]
				var onceDamage = 0, manyDamage = 0
				var onceCritical = 0, manyCritical = 0
				var onceDieCritical = 0, manyDieCritical = 0
				var index, item, roll, value, damageScalar
				var immune, resistant, vulnerable, itemDamage
				var immuneAll = (e.immune && e.immune['all']) || false
				var resistantAll = (e.resistant && e.resistant['all']) || false
				var vulnerableAll = (e.vulnerable && e.vulnerable['all']) || false
				
				for ( index = 0 ; index < e.damage.length ; ++index ) {
					item = e.damage[index]
					roll = item.roll || 1
					damageScalar = 1
					
					immune = (item.type && e.immune && e.immune[item.type]) || false
					resistant = (item.type && e.resistant && e.resistant[item.type]) || false
					vulnerable = (item.type && e.vulnerable && e.vulnerable[item.type]) || false
					
					if ( item.once ) {
						if ( immune || immuneAll ) { continue }
						if ( resistant || resistantAll ) { damageScalar = 0.5 }
						if ( vulnerable || vulnerableAll ) { damageScalar *= 2.0 }
						
						if ( item.die && advantageDamage ) {
							onceDice += roll
							onceDiceCombination = multiply(diceCombinations(item.die * damageScalar, roll), onceDiceCombination)
						}
						
						if ( item.die ) { onceDiceDamage += damageScalar * roll * (1 + item.die) / 2 }
						if ( item.modifier ) { onceModifyDamage += damageScalar * item.modifier }
						if ( item.die > onceDieCritical ) { onceDieCritical = item.die }
					} else {
						var itemDamage = roll * (item.die || 0) / 2 + (item.modifier || 0)
						
						if ( immune === 'once' || (!immune && immuneAll === 'once') ) { onceReduceDamage += itemDamage }
						else if ( immune || (immuneAll && immuneAll !== 'once') ) { continue }
						
						if ( resistant === 'once' || (!resistant && resistantAll === 'once') ) { onceReduceDamage += itemDamage * 0.5 }
						else if ( resistant || (resistantAll && resistantAll !== 'once') ) { damageScalar = 0.5 }
						
						if ( vulnerable === 'once' || (!vulnerable && vulnerableAll === 'once') ) { onceModifyDamage += itemDamage }
						else if ( vulnerable || (vulnerableAll && vulnerableAll !== 'once') ) { damageScalar *= 2.0 }
						
						if ( item.die && advantageDamage ) {
							manyDice += roll
							manyDiceCombination = multiply(diceCombinations(item.die * damageScalar, roll), manyDiceCombination)
						}
						
						if ( item.die ) { manyDiceDamage += damageScalar * roll * (1 + item.die) / 2 }
						if ( item.modifier ) { manyModifyDamage += damageScalar * item.modifier }
						if ( item.die > manyDieCritical ) { manyDieCritical = item.die }
					}
				}
				
				for ( index = 0 ; index < e.reduction.length ; ++index ) {
					item = e.reduction[index]
					roll = item.roll || 1
					
					if ( item.once ) {
						if ( item.die ) { onceReduceDamage += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { onceReduceDamage += item.modifier }
					} else {
						if ( item.die ) { manyReduceDamage += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { manyReduceDamage += item.modifier }
					}
				}
				
				onceDiceDamage += manyDiceDamage
				onceModifyDamage += manyModifyDamage
				onceReduceDamage += manyReduceDamage
				
				manyCritical = manyDiceDamage * 2
				onceCritical = onceDiceDamage * 2
				if ( onceDieCritical < manyDieCritical ) { onceDieCritical = manyDieCritical }
				
				if ( advantageDamage ) {
					onceDice += manyDice
					onceDiceCombination = multiply(onceDiceCombination, manyDiceCombination)
					onceDiceDamage = advantageAverageForDiceCombinations(onceDiceCombination, onceDice)
					
					onceDiceCombination = multiply(onceDiceCombination, onceDiceCombination)
					if ( e.criticalDice > 0 ) { onceDiceCombination = multiply(onceDiceCombination, diceCombinations(onceDieCritical, e.criticalDice)) }
					onceCritical = advantageAverageForDiceCombinations(onceDiceCombination, onceDice + (e.criticalDice || 0))
					
					if ( advantageDamage !== 'once' ) {
						manyDiceDamage = advantageAverageForDiceCombinations(manyDiceCombination, manyDice)
						
						manyDiceCombination = multiply(manyDiceCombination, manyDiceCombination)
						if ( e.criticalDice > 0 ) { manyDiceCombination = multiply(manyDiceCombination, diceCombinations(manyDieCritical, e.criticalDice)) }
						manyCritical = advantageAverageForDiceCombinations(manyDiceCombination, manyDice + (e.criticalDice || 0))
					}
				}
				
				manyDamage = manyDiceDamage + manyModifyDamage - manyReduceDamage
				onceDamage = onceDiceDamage + onceModifyDamage - onceReduceDamage
				manyCritical += manyModifyDamage - manyReduceDamage
				onceCritical += onceModifyDamage - onceReduceDamage
				manyCritical += (e.criticalDamage | 0) + (e.criticalDice | 0) * (manyDieCritical + 1) / 2
				onceCritical += (e.criticalDamage | 0) + (e.criticalDice | 0) * (onceDieCritical + 1) / 2
				
				if ( manyDamage < 0 ) { manyDamage = 0 }
				if ( onceDamage < 0 ) { onceDamage = 0 }
				if ( manyCritical < 0 ) { manyCritical = 0 }
				if ( onceCritical < 0 ) { onceCritical = 0 }
				
				var attacks = Math.max(+e.attacks, 1)
				var armorClass = e.armorClass || 10
				var onceArmorClass = 0, manyArmorClass = 0
				var onceModifierHit = 0, manyModifierHit = 0
				var onceChanceToHit, manyChanceToHit, chanceToHit
				var toHit, toCritical, toNearlyMiss, toMiss
				var h, c, hi, ci, p
				
				if ( e.armorClass === 0 ) { return onceDamage + (attacks - 1) * manyDamage }
				if ( e.armorClass === 99 ) { return onceCritical + (attacks - 1) * manyCritical }
				
				for ( index = 0 ; index < e.hit.length ; ++index ) {
					item = e.hit[index]
					roll = item.roll || 1
					
					if ( item.once ) {
						if ( item.die ) { onceModifierHit += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { onceModifierHit += item.modifier }
					} else {
						if ( item.die ) { manyModifierHit += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { manyModifierHit += item.modifier }
					}
				}
				
				for ( index = 0 ; index < e.defense.length ; ++index ) {
					item = e.defense[index]
					roll = item.roll || 1
					
					if ( item.once ) {
						if ( item.die ) { onceArmorClass += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { onceArmorClass += item.modifier }
					} else if ( item.afterFirst ) {
						if ( item.die ) { manyArmorClass += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { manyArmorClass += item.modifier }
					} else {
						if ( item.die ) { armorClass += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { armorClass += item.modifier }
					}
				}
				
				toLimit = 20
				toHit = Math.min(Math.max(2, armorClass + onceArmorClass - manyModifierHit - (onceModifierHit < 0 ? onceModifierHit : 0)), 20) - 1
				toCritical = Math.min(Math.max(toHit + 1, e.criticalRoll || 20), 20) - 1
				toNearlyMiss = onceModifierHit < 0 ? toHit : Math.min(Math.max(1, toHit - onceModifierHit), 19)
				
				if ( e.advantageHit && !e.disadvantageHit ) {
					toLimit = 400
					toHit = toHit * toHit
					toCritical = toCritical * toCritical
					toNearlyMiss = toNearlyMiss * toNearlyMiss
				}
				
				if ( e.disadvantageHit && !e.advantageHit ) {
					toLimit = 400
					toHit = 400 - (20 - toHit) * (20 - toHit)
					toCritical = 400 - (20 - toCritical) * (20 - toCritical)
					toNearlyMiss = 400 - (20 - toNearlyMiss) * (20 - toNearlyMiss)
				}
				
				//	TODO: onceArmorClass should apply strategically instead of always with the first attack
				onceChanceToHit = [,toNearlyMiss,,toCritical - toHit,,toLimit - toCritical,,toHit - toNearlyMiss]
				
				toLimit = 20
				toHit = Math.min(Math.max(2, armorClass + manyArmorClass - manyModifierHit), 20) - 1
				toCritical = Math.min(Math.max(toHit + 1, e.criticalRoll || 20), 20) - 1
				toNearlyMiss = toHit // onceModifierHit < 0 ? toHit : Math.min(Math.max(1, toHit - onceModifierHit), 19)
				
				if ( (e.advantageHit && e.advantageHit !== 'once') && !(e.disadvantageHit && e.disadvantageHit !== 'once') ) {
					toLimit = 400
					toHit = toHit * toHit
					toCritical = toCritical * toCritical
					toNearlyMiss = toNearlyMiss * toNearlyMiss
				}
				
				//	TODO: disadvantage until hit
				if ( (e.disadvantageHit && e.disadvantageHit !== 'once') && !(e.advantageHit && e.advantageHit !== 'once') ) {
					toLimit = 400
					toHit = 400 - (20 - toHit) * (20 - toHit)
					toCritical = 400 - (20 - toCritical) * (20 - toCritical)
					toNearlyMiss = 400 - (20 - toNearlyMiss) * (20 - toNearlyMiss)
				}
				
				manyChanceToHit = [,toNearlyMiss,,toCritical - toHit,,toLimit - toCritical,,toHit - toNearlyMiss]
				
				chanceToHit = onceChanceToHit
				
				for ( index = 1 ; index < attacks ; ++index ) {
					chanceToHit = chanceToHitProduct(chanceToHit, manyChanceToHit)
				}
				
				chanceToHit = chanceToHitResolveNearMisses(chanceToHit)
				chanceToHit = chanceToHitNormalize(chanceToHit)
				chanceToCritical = 0
				damage = 0
				
				for ( h = 0, hi = 1 ; h <= attacks ; ++h, hi *= 3 ) {
					for ( c = 0, ci = 1 ; h + c <= attacks ; ++c, ci *= 5 ) {
						var p = chanceToHit[hi * ci] || 0
						
						if ( h > 0 ) { damage += p * h * ((onceDamage - manyDamage) / (h + c) + manyDamage) }
						if ( c > 0 ) { damage += p * c * ((onceCritical - manyCritical) / (h + c) + manyCritical) }
						if ( c > 0 ) { chanceToCritical += p }
					}
				}
				
				if ( e.criticalBonusAttack ) {
					damage += chanceToCritical * manyChanceToHit[5] * manyDamage / toLimit
					damage += chanceToCritical * manyChanceToHit[7] * manyCritical / toLimit
				}
				
				return damage
			}
			
			function experiment() {
			}
			
			function handleChanceToHit(event) {
				var input = document.getElementById('chance-to-hit-input')
				var output = document.getElementById('chance-to-hit-text')
				if ( !input.value ) { output.innerHTML = ""; return }
				
				experiment()
				
				var armorClass = Math.max(+input.value, 0)
				if ( !armorClass ) { return }
				
				var chanceToHit = (21 - Math.min(Math.max(2, armorClass), 20)) / 20
				var chanceToCritical = (21 - Math.min(Math.max(20, armorClass), 20)) / 20
				var advantageChanceToHit = 1 - (1 - chanceToHit) * (1 - chanceToHit)
				var disadvantageChanceToHit = chanceToHit * chanceToHit
				
				output.innerHTML = "Chance " + (chanceToHit * 100).toFixed(1) + "%" +
					", with advantage " + (advantageChanceToHit * 100).toFixed(1) + "%" + " (+" + Math.round((advantageChanceToHit - chanceToHit) * 20) + ")" +
					", with disadvantage " + (disadvantageChanceToHit * 100).toFixed(1) + "%" + " (-" + Math.round((chanceToHit - disadvantageChanceToHit) * 20) + ")"
			}
			
			function handleAdvantage(event) {
				var input = document.getElementById('advantage-input')
				var output = document.getElementById('advantage-text')
				if ( !input.value ) { output.innerHTML = ""; return }
				
				var matched = input.value.match(/\d*d\d+/g)
				if ( !(matched && matched.length > 0) ) { return }
				
				var rolling = ""
				var dc = [1]
				var dice = 0
				var die, roll
				var average = 0
				var maximum = 0
				
				for ( match of matched ) {
					var s = match.split("d")
					
					roll = s.length > 1 ? +s[0] : 0
					die = s.length > 1 ? +s[1] : +s[0]
					if ( !( die > 1 ) ) { continue }
					if ( !( roll > 1 ) ) { roll = 1 }
					
					dc = multiply(dc, diceCombinations(die, roll))
					dice += roll
					maximum += roll * die
					average += roll * (die + 1) / 2
					rolling += roll + "d" + die + " "
				}
				
				var advantage = advantageAverageForDiceCombinations(dc, dice)
				
				output.innerHTML = dice + "-" + maximum + " average " + average.toFixed(2) +
					", with advantage " + advantage.toFixed(2) +
					", with disadvantage " + (average * 2 - advantage).toFixed(2)
			}
			
			function handleEffectiveness(event) {
				var input = document.getElementById('effectiveness-input')
				var output = document.getElementById('effectiveness-text')
				if ( !input.value ) { output.innerHTML = ""; return }
				
				var parsed = parseEffectiveness(input.value)
				if ( !parsed.damage.length ) { return }
				
				var effectiveness = computeAverageEffectiveness(parsed)
				var rolled, index, sum = 0, samples = 10
				var example = []
				
				for ( index = 0 ; index < samples ; ++index ) {
					rolled = computeRandomEffectiveness(parsed)
					example.push(rolled)
					sum += rolled
				}
				
				var montecarlo = Math.max(samples, 10)
				for ( index = 0 ; index < montecarlo - samples ; ++index ) {
					rolled = computeRandomEffectiveness(parsed)
					sum += rolled
				}
				
				output.innerHTML = "Average damage per turn: " + effectiveness.toFixed(2) + " (e.g. " + (sum / montecarlo).toFixed(2) + " with " + example.join(", ") + ")"
			}
		</script>
	</head>
	<body>
		<h4>Attack Effectiveness</h4>
		
		<span id='effectiveness-description' class='tiny'>hit / damage # attacks @ target</span><br/>
		<input type='text' id='effectiveness-input' name='effectiveness' size='60' placeholder='+5 /d8+3s #2 @ 16' oninput='handleEffectiveness(event)'>
		<p><span id='effectiveness-text'></span></p>
		
		<input id='toggle-attack-examples' type='checkbox' class='toggle'/>
		<label for='toggle-attack-examples' class='toggle'>Examples</label>
		<table id='attack-examples' class='toggled'>
			<tr><td>Default Armor Class</td><td>@10</td><td>Target has AC 10</td></tr>
			<tr><td>Default Attacks</td><td>#1</td><td>Attack 1 time</td></tr>
			<tr><td>Proficiency Bonus</td><td>+2</td><td>Hit +2</td></tr>
			<tr><td>Ability Bonus</td><td>+3/+3</td><td>Hit and Damage +3</td></tr>
			<tr><td>Half Orc: Savage Attacks</td><td>/ +c1d</td><td>Add 1 die to critical damage</td></tr>
			<tr><td>Barbarian: Rage Damage</td><td>/ +2</td><td>Damage +2</td></tr>
			<tr><td>Barbarian: Reckless Attack</td><td>a</td><td>Advantage to hit</td></tr>
			<tr><td>Barbarian: Brutal Critical</td><td>/ +c1d</td><td>Add 1 die to critical damage</td></tr>
			<tr><td>Bard: Bardic Inspiration</td><td>+d6o</td><td>Hit +1d6 one time</td></tr>
			<tr><td>Cleric: Potent Spellcasting</td><td>/ +5</td><td>Damage +5</td></tr>
			<tr><td>Cleric: Divine Strike</td><td>/ +d8ro</td><td>Damage +d8 radiant</td></tr>
			<tr><td>Cleric: Avatar of Battle</td><td>@ rbps</td><td>Resist bludgeoning, piercing and slashing damage</td></tr>
			<tr><td>Fighter: Extra Attack</td><td>#2</td><td>Attack 2 times</td></tr>
			<tr><td>Champion: Improved Critical</td><td>c19</td><td>Critical damage on 19 or higher</td></tr>
			<tr><td>Champion: Superior Critical</td><td>c18</td><td>Critical damage on 18 or higher</td></tr>
			<tr><td>Battle Master: Lunge</td><td>/ +d8</td><td>Damage +d8</td></tr>
			<tr><td>Battle Master: Precision</td><td>+d8</td><td>Hit +d8</td></tr>
			<tr><td>Battle Master: Parry</td><td>@ -d8o-3o</td><td>Reduce damage by d8+3 one time</td></tr>
			<tr><td>Monk: Deflect Missile</td><td>@ -d10o-5o</td><td>Reduce damage by d8+5 one time</td></tr>
			<tr><td>Monk: Shadow Step</td><td>ao</td><td>Advantage to hit one time</td></tr>
			<tr><td>Paladin: Improved Divine Smite</td><td>/ +d8r</td><td>Damage +d8 radiant</td></tr>
			<tr><td>Ranger: Foe Slayer</td><td>+5o</td><td>Hit +5 one time</td></tr>
			<tr><td>Ranger: Colossus Slayer</td><td>/ +d8o</td><td>Damage +d8 one time</td></tr>
			<tr><td>Ranger: Multiattack Defense</td><td>@ +4m</td><td>Armor class +4 after first hit</td></tr>
			<tr><td>Rogue: Sneak Attack</td><td>/ +2d6o</td><td>Damage +2d6 one time</td></tr>
			<tr><td>Rogue: Uncanny Dodge</td><td>@ ro</td><td>Resist all damage one time</td></tr>
			<tr><td>Rogue: Assassinate</td><td>a c1</td><td>Advantage to hit, Critical damage on any roll</td></tr>
			<tr><td>Warlock: Lifedrinker</td><td>/ +3</td><td>Damage +3</td></tr>
			<tr><td>Sorcerer: Elemental Affinity</td><td>/ +3</td><td>Damage +3</td></tr>
			<tr><td>Fighting Style: Archery</td><td>+2</td><td>Hit +2</td></tr>
			<tr><td>Fighting Style: Defense</td><td>@ +1</td><td>Armor Class +1</td></tr>
			<tr><td>Fighting Style: Dueling</td><td>/ +2</td><td>Damage +2</td></tr>
			<!-- tr><td>Fighting Style: Great Weapon Fighting</td><td>/ r2</td><td>(not implemented)</td></tr -->
			<tr><td>Feat: Charger</td><td>/ +5</td><td>Damage +5</td></tr>
			<tr><td>Feat: Dual Wielder</td><td>@ +1</td><td>Armor Class +1</td></tr>
			<tr><td>Feat: Great Weapon Master</td><td>-5/+10#cb</td><td>Hit -5, damage +10, bonus attack after critical hit</td></tr>
			<tr><td>Feat: Heavy Armor Master</td><td>@ -3</td><td>Target reduces damage by 3</td></tr>
			<tr><td>Feat: Savage Attacker</td><td>/ ao</td><td>Advantage on damage one time</td></tr>
			<tr><td>Feat: Sharpshooter</td><td>-5/+10</td><td>Hit -5, damage +10</td></tr>
			<tr><td>Bane</td><td>-d4</td><td>Hit -d4</td></tr>
			<tr><td>Bless</td><td>+d4</td><td>Hit +d4</td></tr>
			<tr><td>Foresight</td><td>a</td><td>Advantage on hit</td></tr>
			<tr><td>Haste</td><td>#2 @ +2</td><td>Attack one more time, Armor class +2</td></tr>
			<tr><td>Hex</td><td>/ +d6n</td><td>Damage +d6 necrotic</td></tr>
			<tr><td>Invisibility</td><td>ao</td><td>Advantage on hit one time</td></tr>
			<tr><td>Stoneskin</td><td>@ rbps</td><td>Resist bludgeoning, piercing and slashing damage</td></tr>
			<tr><td>Bracers of Archery</td><td>/ +2</td><td>Damage +2</td></tr>
			<tr><td>Bracers of Defense</td><td>@ +2</td><td>Armor Class +2</td></tr>
			<tr><td>Cloak of Displacement</td><td>dh</td><td>Disadvantage on hit until hit</td></tr>
			<tr><td>Dwarven Thrower</td><td>+3/d8+d8+3</td><td>Hit +3, damage 2d8+3</td></tr>
			<tr><td>Magic Weapon</td><td>+3/+3</td><td>Hit and damage +3</td></tr>
			<tr><td>Sword of Sharpness</td><td>+1/+1+c14</td><td>Hit and damage +1, critical damage +14</td></tr>
			<tr><td>Fighter 1: Longsword</td><td>+2+3/d8+3#1@12</td><td>Hit +5, damage d8+3, 1 attack, target AC 12</td></tr>
			<tr><td>Warlock 20: Wand +3, Hex</td><td>+6+5+3/d10+5e+d6n#4</td><td>Hit +14, damage d10+d6+5, 4 attacks</td></tr>
			<tr><td>Champion 20: Greatsword +3</td><td>c18+6+5+3-5/2d6+3m+5+10#4cb</td><td>Hit +9, critical on 18, damage 2d6+18, 4 attacks, bonus attack on critical</td></tr>
			<tr><td>Fighter 20: Longbow +3, Bracers</td><td>+6+5+3+2-5+d12o/d8+3m+5+2+10#4</td><td>Hit +11, +d12 one time, damage d8 + 20, 4 attacks</td></tr>
			<tr><td>Barbarian 20: Greataxe +3</td><td>+6+7+3-5/d12+3m+7+10+4+c4d#2cb</td><td>Hit +11, damage d12+24, critical +4 dice, 2 attacks, bonus attack on critical</td></tr>
			<tr><td colspan=3/></td></tr>
		</table>
		
		<p>
			<hr/>
			Chance to hit AC: <input type='number' id='chance-to-hit-input' name='advantage' size='40' placeholder='16' oninput='handleChanceToHit(event)'><br/>
			<span id='chance-to-hit-text'> </span>
		</p>
		
		<p>
			<hr/>
			Average of die roll: <input type='text' id='advantage-input' name='advantage' size='40' placeholder='4d6' oninput='handleAdvantage(event)'><br/>
			<span id='advantage-text'> </span>
		</p>
		
		<p>
			<hr/>
			
			<span class='tiny'>Some modifiers and combinations are not fully supported.  Resistance and vulnerability are inaccurate when combined with advantage on damage.  Disadvantage on attack may apply to the first attack or all attacks but not until the first hit.  Rerolling low dice is not supported.</span>
		</p>
	</body>
</html>
