<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Attack Effectiveness</title>
		<meta name="author" content="Eric Cole">
		<meta name="version" content="0.2">
		<meta name="keywords" content="dnd,5e,dungeons,dragons,attack,effectiveness">
		<meta name="description" content="Compute Effectiveness of Attacks">
		<link rel="stylesheet" href="main.css">
		<style>
			input.toggle:not(:checked) + label + table.toggled { display:none; }
			table#attack-examples td:nth-child(2) { white-space:nowrap; }
			table#attack-examples td:nth-child(3) { font-size:60%; }
		</style>
		<script src="data/dnd.js"></script>
		
		<script lang="javascript">
			var damageTypeMap = {
				'':'all',
				'a':'acid',
				'b':'bludgeoning',
				'bd':'bludgeoning',
				'c':'cold',
				'e':'force',
				'fe':'force',
				'f':'fire',
				'fi':'fire',
				'l':'lightning',
				'm':'magic', // magic weapon damage distinct from non magical bludgeoning, piercing, and slashing weapon damage
				'n':'necrotic',
				'p':'piercing',
				'pi':'piercing',
				'q':'poison',
				'po':'poison',
				'r':'radiant',
				's':'slashing',
				'sl':'slashing',
				't':'thunder',
				'y':'psychic',
				'py':'psychic'
			};
			
			function factorial(n) {
				var result = 1.0
				
				for ( var i = 2 ; i <= n ; ++i ) { result *= i }
				
				return result
			}
			
			function repeat(count, value) {
				var r = []
				
				for ( var i = 0 ; i < count ; ++i ) { r[i] = value }
				
				return r
			}
			
			function multiply(a, b) {
				var p = []
				var i, j
				
				for ( i = 0 ; i < a.length ; ++i ) {
					for ( j = 0 ; j < b.length ; ++j ) {
						p[i + j] = a[i] * b[j] + (p[i + j] || 0)
					}
				}
				
				return p
			}
			
			function power(a, n) {
				if ( !(n > 1 && a.length > 0) ) { return a }
				if ( !(a.length > 1) ) { return [Math.pow(a[0], n)] }
				
				var b = [1]
				
				while ( n > 1 ) {
					if ( n & 1 ) {
						b = multiply(b, a)
					}
					
					n = n >> 1
					a = multiply(a, a)
				}
				
				return b.length > 1 ? multiply(b, a) : a
			}
			
			function binomialcoefficients(n) {
				var result = [1]
				if ( !( n > 0 ) ) { return result }
				
				var i, d = 1.0, c = n, k = n
				
				for ( i = 1 ; i < k ; ++i ) {
					result.push(c)
					c = c * --n / ++d
				}
				
				result.push(1)
				
				return result
			}
			
			function trinomialcoefficients(n) {
				if ( !( n > 0 ) ) { return [1] }
				
				var result = []
				var f, i, j, k, c
				
				f = 1
				
				for ( i = 0 ; i <= n ; ++i ) {
					c = f
					f = f * (n-i) / (i+1)
					
					for ( j = 0, k = n - i ; j <= n - i ; ++j, --k ) {
						if ( j ) { c = c * (k+1) / j }
						
						result[j + 2 * k] = c + (result[j + 2 * k] | 0)
					}
				}
				
				return result
			}
			
			function binomialcoefficient(n, k) {
				/*
					combinatorial number
					n choose k -- ways to choose k elements from n elements
					
					 n       n!
					( ) = --------
					 k    k!(n-k)!
				*/
				
				if ( k > 0 && k < n ) {
					if ( k > n - k ) { k = n - k } // symmetric
					
					var i, d = 1.0, c = n
					
					for ( i = 1 ; i < k ; ++i ) {
						c = c * --n / ++d
					}
					
					return c
				} else {
					return ( k < 0 || k > n ) ? 0 : 1
				}
			}
			
			function dieRoll(die) {
				return 1 + Math.floor(Math.random() * die)
			}
			
			function diceRoll(die, roll) {
				var sum = 0
				
				for ( var index = 0 ; index < roll ; ++index ) {
					sum += dieRoll(die)
				}
				
				return sum
			}
			
			function diceCombinations(die, roll) {
				/*
					diceCombinations can be combined with multiply
					
					multiply(diceCombinations(6, 2), diceCombinations(8, 2))
				*/
				
				if ( !(roll > 0 && die > 1) ) { return [1] }
				if ( !(roll > 1) ) { return repeat(die, 1) }
				if ( !(die > 2) ) { return binomialcoefficients(roll) }
				
				return power(repeat(die, 1), roll)
			}
			
			function advantageAverageForDiceCombinations(c, roll) {
				//	roll must be the total number of dice combined
				var average = 0
				var i, j, p
				var sum = 0
				
				for ( i = 0 ; i < c.length ; ++i ) {
					sum += c[i]
					p = c[i]	// both rolls are the same
					
					for ( j = 0 ; j < i ; ++j ) {
						p += 2 * c[j]	//	one roll was less
					}
					
					average += p * c[i] * (i + roll)
				}
				
				return average / (sum * sum)
			}
			
			function advantageAverageForUniformDice(die, roll, disadvantage) {
				if ( !(die > 1) ) {
					return 1
				}
				
				var average
				
				if ( roll > 1 ) {
					var c = diceCombinations(die, roll)
					
					average = advantageAverageForDiceCombinations(c, roll)
				} else {
					//	∑ k(2k-1) / n² == (n+1)(4n-1)/(6n)
					average = (die + 1)*(4*die - 1)/(6*die)
				}
				
				return disadvantage ? (roll || 1) * (die + 1) - average : average
			}
			
			function damageTypeApplies(type, magical) {
				var special = ['bludgeoning', 'piercing', 'slashing']
				
				return !magical || special.indexOf(type) < 0
			}
			
			function parseEffectivenessDamageType(string, result, key) {
				if ( !result[key] ) { result[key] = new Object() }
				
				var once = string.slice(-1) === 'o'
				var type = string.slice(1, once ? -1 : undefined)
				var value = once ? 'once' : true
				var index, letter, name = damageTypeMap[type]
				
				if ( name ) {
					result[key][name] = value
				} else if ( Object.values(damageTypeMap).indexOf(type) < 0 ) {
					for ( index = 0 ; index < type.length ; ++index ) {
						letter = type.charAt(index)
						result[key][damageTypeMap[letter] || letter] = value
					}
				} else {
					result[key][type] = value
				}
			}
			
			function parseSingleEffectiveness(string) {
				var result = new Object()
				
				result.armorClass = 10
				result.hit = []
				result.damage = []
				result.defense = []
				result.reduction = []
				result.magical = false
				string = string.toLowerCase().replace(/,•/g, " ")
				
				var match, index, found, value, roll, once, type, matched, length, item
				var beginHit = 0
				var beginDamage = string.indexOf('/', beginHit)
				var beginAttacks = string.indexOf('#', beginDamage)
				var beginDefense = string.indexOf('@', beginAttacks < 0 ? beginDamage : beginAttacks)
				var closeAttacks = beginDefense < 0 ? undefined : beginDefense
				var closeDamage = beginAttacks < 0 ? closeAttacks : beginAttacks
				var closeHit = beginDamage < 0 ? closeDamage : beginDamage
				
				var stringDefense = beginDefense < 0 ? '10' : string.slice(beginDefense + 1)
				var stringAttacks = beginAttacks < 0 ? '' : string.slice(beginAttacks + 1, closeAttacks)
				var stringDamage = beginDamage < 0 ? '' : string.slice(beginDamage + 1, closeDamage)
				var stringHit = string.slice(beginHit, closeHit)
				
				result.input = [stringHit, stringDamage, stringAttacks, stringDefense]
				
				var patternHit = /([-+]\d*d?\d+o?|a[o]?|d[oh]?|c\d+|rm|m)/g
				var matchHit = stringHit.split(patternHit)
				
				for ( index = 0 ; index < matchHit.length ; ++index ) {
					match = matchHit[index]
					
					if ( !( index & 1 ) ) {
						if ( match.trim() ) { break } else { continue }
					}
					
					if ( match === 'm' ) {
						result.magical = true
					} else if ( match === 'a' ) {
						result.advantageHit = true
					} else if ( match === 'ao' ) {
						if ( !result.advantageHit ) { result.advantageHit = 'once' }
					} else if ( match === 'rm' ) {
						result.advantageMiss = true
					} else if ( match === 'd' ) {
						if ( result.hit.length > 0 ) { break } // unqualified die
						result.disadvantageHit = true
					} else if ( match === 'do' ) {
						if ( !result.disadvantageHit ) { result.disadvantageHit = 'once' }
					} else if ( match === 'dh' ) {
						if ( !result.disadvantageHit || result.disadvantageHit === 'once' ) { result.disadvantageHit = 'hit' }
					} else if ( match.charAt(0) === 'c' ) {
						result.criticalRoll = match.slice(1) | 0
					} else {
						found = match.indexOf('o')
						
						if ( !( found < 0 ) ) {
							once = true
							match = match.slice(0, found)
						}
						
						found = match.indexOf('d')
						
						if ( found < 0 ) {
							roll = false
							value = match | 0
						} else {
							roll = match.slice(0, found) | 0
							value = match.slice(found + 1) | 0
							if ( !roll ) { roll = match.charAt(0) === '-' ? -1 : 1 }
						}
						
						item = roll ? {'die':value, 'roll':roll} : {'modifier':value}
						if ( once ) { item.once = true }
						if ( value ) { result.hit.push(item) }
					}
				}
				
				var patternDiceModifierText = /([-+]?\d*)(d?)(\d+)([a-z]*)/
				var patternDamage = /([-+]?\d*d?\d+[a-z]*|[+]c?\d+d?|\b[mr]\d+|\bao?)/g
				var matchDamage = stringDamage.split(patternDamage)
				
				for ( index = 0 ; index < matchDamage.length ; ++index ) {
					match = matchDamage[index]
					
					if ( !( index & 1 ) ) {
						if ( match.trim() ) { break } else { continue }
					}
					
					if ( match === 'a' ) {
						result.advantageDamage = true
					} else if ( match === 'ao' ) {
						if ( !result.advantageDamage ) { result.advantageDamage = 'once' }
					} else if ( match.charAt(0) === 'm' ) {
						value = match.slice(1) | 0
						if ( value > 0 ) { result.minimumDamageRoll = value }
					} else if ( match.charAt(0) === 'r' ) {
						value = match.slice(1) | 0
						if ( value > 0 ) { result.lowDamageReroll = value }
					} else if ( match.slice(0, 2) === '+c' ) {
						found = match.indexOf('d')
						if ( found < 0 ) {
							value = match.slice(2) | 0
							result.criticalDamage = (value | 0) + (result.criticalDamage | 0)
						} else {
							value = match.slice(2, found) | 0
							result.criticalDice = (value | 0) + (result.criticalDice | 0)
						}
					} else {
						matched = match.match(patternDiceModifierText)
						type = matched[4]
						once = type.slice(-1) === 'o'
						
						if ( matched[2] === 'd' ) {
							roll = matched[1] | 0
							value = matched[3] | 0
							if ( !roll ) { roll = matched[1].charAt(0) === '-' ? -1 : 1 }
						} else {
							roll = false
							value = (matched[1] + matched[3]) | 0
						}
						
						item = roll ? {'die':value, 'roll':roll} : {'modifier':value}
						
						if ( once ) {
							item.once = true
							type = type.slice(0, -1)
						}
						
						//console.log("parseEffectivenessDamageType " + match + " => " + (type ? type + " => " + damageTypeMap[type] : '-'))
						
						if ( type ) {
							item.type = damageTypeMap[type] || type
							length = result.damage.length
							
							if ( length > 0 && !roll && result.damage[length - 1].roll && !result.damage[length - 1].type ) {
								result.damage[length - 1].type = item.type
							}
						}
						
						result.damage.push(item)
					}
				}
				
				var patternAttacks = /(\d+|cb|b|r)/g
				var matchAttacks = stringAttacks.split(patternAttacks)
				
				for ( index = 0 ; index < matchAttacks.length ; ++index ) {
					match = matchAttacks[index]
					
					if ( !( index & 1 ) ) {
						if ( match.trim() ) { break } else { continue }
					}
					
					if ( match === 'cb' ) {
						result.criticalBonusAttack = true
					} else if ( match === 'b' ) {
						result.bonusAction = true
					} else if ( match === 'r' ) {
						result.reaction = true
					} else {
						value = match | 0
						if ( value > 0 ) { result.attacks = value }
					}
				}
				
				var patternDefense = /(\d+|[-+]\d*d?\d+[mo]?|[vr][a-z]*|i[a-z]+|d[oh]?|ao?)/g
				var matchDefense = stringDefense.split(patternDefense)
				
				for ( index = 0 ; index < matchDefense.length ; ++index ) {
					match = matchDefense[index]
					
					if ( !( index & 1 ) ) {
						if ( match.trim() ) { break } else { continue }
					}
					
					if ( match === 'a' ) {
						result.advantageHit = true
					} else if ( match === 'ao' ) {
						if ( !result.advantageHit ) { result.advantageHit = 'once' }
					} else if ( match === 'd' ) {
						if ( result.hit.length > 0 ) { break }
						result.disadvantageHit = true
					} else if ( match === 'do' ) {
						if ( !result.disadvantageHit ) { result.disadvantageHit = 'once' }
					} else if ( match === 'dh' ) {
						if ( !result.disadvantageHit || result.disadvantageHit === 'once' ) { result.disadvantageHit = 'hit' }
					} else if ( match.charAt(0) === '+' ) {
						matched = match.match(patternDiceModifierText)
						
						if ( matched[2] === 'd' ) {
							roll = matched[1] | 0
							value = matched[3] | 0
							if ( !roll ) { roll = 1 }
						} else {
							roll = false
							value = (matched[1] + matched[3]) | 0
						}
						
						item = roll ? {'die':value, 'roll':roll} : {'modifier':value}
						
						if ( matched[4] === 'o' ) { item.once = true }
						if ( matched[4] === 'm' ) { item.afterFirst = true }
						
						result.defense.push(item)
					} else if ( match.charAt(0) === '-' ) {
						matched = match.match(patternDiceModifierText)
						
						if ( matched[2] === 'd' ) {
							roll = -matched[1] | 0
							value = matched[3] | 0
							if ( !roll ) { roll = 1 }
						} else {
							roll = 0
							value = -(matched[1] + matched[3]) | 0
						}
						
						item = roll ? {'die':value, 'roll':roll} : {'modifier':value}
						
						if ( matched[4] === 'o' ) { item.once = true }
						
						result.reduction.push(item)
					} else if ( match.charAt(0) === 'v' ) {
						parseEffectivenessDamageType(match, result, 'vulnerable')
					} else if ( match.charAt(0) === 'r' ) {
						parseEffectivenessDamageType(match, result, 'resistant')
					} else if ( match.charAt(0) === 'i' ) {
						parseEffectivenessDamageType(match, result, 'immune')
					} else {
						value = match | 0
						if ( value >= 0 ) { result.armorClass = value }
					}
				}
				
				if ( !result.attacks ) {
					result.attacks = result.bonusAction || result.reaction ? 0 : 1
				}
				
				return result
			}
			
			function computeSingleRandomEffectiveness(e) {
				var effectiveness = 0
				var asComputeAverage = e.asComputeAverage || false
				var summary = []
				var hasHit = false, hasBoosted = false, hasDefended = false
				var hasBonus = true
				var hasAdvantage, hasDisadvantage
				var attack, attacks = Math.max(+e.attacks, 1)
				var rolled, roll, die, toHit
				var modifierHit, onceModifierHit
				var armorClass, onceArmorClass, hit
				var damageRolled, damageAdvantageRolled, damageModifier
				var index, item, type, previousType
				var isCritical
				var advantageHit = e.advantageHit
				var disadvantageHit = e.disadvantageHit
				var advantageDamage = e.advantageDamage
				var damageDice, dieForCritical
				var damageScalar, immune, resistant, vulnerable
				var immuneAll = (e.immune && e.immune['all']) || false
				var resistantAll = (e.resistant && e.resistant['all']) || false
				var vulnerableAll = (e.vulnerable && e.vulnerable['all']) || false
				
				immuneAll = immuneAll ? immuneAll !== 'once' ? 2 : 1 : 0
				resistantAll = resistantAll ? resistantAll !== 'once' ? 2 : 1 : 0
				vulnerableAll = vulnerableAll ? vulnerableAll !== 'once' ? 2 : 1 : 0
				
				for ( attack = 0 ; attack < attacks ; ++attack ) {
					modifierHit = 0
					onceModifierHit = 0
					
					for ( index = 0 ; index < e.hit.length ; ++index ) {
						item = e.hit[index]
						
						if ( item.once ) {
							if ( item.modifier ) { onceModifierHit += item.modifier }
							if ( item.die ) { onceModifierHit += diceRoll(item.die, item.roll || 1) }
						} else {
							if ( item.modifier ) { modifierHit += item.modifier }
							if ( item.die ) { modifierHit += diceRoll(item.die, item.roll || 1) }
						}
					}
					
					armorClass = e.armorClass || 10
					onceArmorClass = 0
					
					for ( index = 0 ; index < e.defense.length ; ++index ) {
						item = e.defense[index]
						
						if ( item.once ) {
							if ( item.modifier ) { onceArmorClass += item.modifier }
							if ( item.die ) { onceArmorClass += diceRoll(item.die, item.roll || 1) }
						} else if ( !(item.afterFirst && !hasHit) ) {
							if ( item.modifier ) { armorClass += item.modifier }
							if ( item.die ) { armorClass += diceRoll(item.die, item.roll || 1) }
						}
					}
					
					toHit = dieRoll(20)
					hasAdvantage = false
					hasDisadvantage = false
					
					if ( disadvantageHit ) {
						if ( disadvantageHit === 'once' ) { disadvantageHit = 0 }
						if ( !advantageHit ) { hasDisadvantage = true; toHit = Math.min(dieRoll(20), toHit) }
					}
					
					if ( advantageHit ) {
						if ( !hasDisadvantage ) { hasAdvantage = true; toHit = Math.max(dieRoll(20), toHit) }
						if ( advantageHit === 'once' ) { advantageHit = 0 }
					}
					
					if ( toHit < 2 ) {
						summary.push("missed AC " + armorClass + " with 1")
						continue
					}
					
					if ( toHit < 20 ) {
						hit = toHit + modifierHit - armorClass
						
						if ( !hasDefended && !(hit < 0) && hit < onceArmorClass ) {
							hasDefended = true
							armorClass += onceArmorClass
							hit -= onceArmorClass
						}
						
						if ( !hasBoosted && hit < 0 && !(hit + onceModifierHit < 0) ) {
							hasBoosted = true
							modifierHit += onceModifierHit
							hit += onceModifierHit
						}
						
						if ( !hasDefended && !(hit < 0) && hit < onceArmorClass ) {
							hasDefended = true
							armorClass += onceArmorClass
							hit -= onceArmorClass
						}
					}
					
					if ( toHit < 20 && toHit + modifierHit < armorClass ) {
						summary.push("missed AC " + armorClass + " with " + toHit + (modifierHit > 0 ? "+" + modifierHit : "") + (hasAdvantage ? " (advantage)": "") + (hasDisadvantage ? " (disadvantage)": ""))
						continue
					}
					
					if ( disadvantageHit === 'hit' ) {
						disadvantageHit = 0
					}
					
					damageRolled = 0
					damageAdvantageRolled = 0
					damageModifier = 0
					dieForCritical = 0
					damageDice = []
					
					for ( index = 0 ; index < e.damage.length ; ++index ) {
						item = e.damage[index]
						type = item.type || previousType
						previousType = type
						damageScalar = 1
						
						immune = type && e.immune && damageTypeApplies(type, e.magical) && e.immune[type]
						resistant = type && e.resistant && damageTypeApplies(type, e.magical) && e.resistant[type]
						vulnerable = type && e.vulnerable && e.vulnerable[type]
						
						immune = (immune ? immune !== 'once' ? 2 : 1 : 0) | immuneAll
						resistant = (resistant ? resistant !== 'once' ? 2 : 1 : 0) | resistantAll
						vulnerable = (vulnerable ? vulnerable !== 'once' ? 2 : 1 : 0) | vulnerableAll
						
						if ( immune && !(hasHit && immune === 1) ) { continue }
						if ( resistant && !(hasHit && resistant === 1) ) { damageScalar = 0.5 }
						if ( vulnerable && !(hasHit && vulnerable === 1) ) { damageScalar *= 2.0 }
						
						if ( !(item.once && hasHit) ) {
							if ( item.die > 0 ) { damageDice.push({'die':item.die, 'roll':item.roll, 'scalar':damageScalar}) }
							if ( item.modifier ) { damageModifier += item.modifier * damageScalar }
							if ( item.die > dieForCritical ) { dieForCritical = item.die }
						}
					}
					
					for ( index = 0 ; index < e.reduction.length ; ++index ) {
						item = e.reduction[index]
						
						if ( !(item.once && hasHit) ) {
							if ( item.die ) { damageModifier -= diceRoll(item.die, item.roll || 1) }
							if ( item.modifier ) { damageModifier -= item.modifier }
						}
					}
					
					isCritical = !(toHit < (e.criticalRoll || 20))
					var damageDiceLength = damageDice.length
					
					if ( isCritical ) {
						damageDice = damageDice.concat(damageDice)
						if ( e.criticalDamage ) { damageModifier += e.criticalDamage }
						if ( e.criticalDice > 0 && dieForCritical ) { damageDice.push({'die':dieForCritical, 'roll':e.criticalDice, 'scalar':1}) }
						if ( e.criticalBonusAttack && hasBonus ) { hasBonus = false; attacks += 1 }
					}
					
					for ( index = 0 ; index < damageDice.length ; ++index ) {
						item = damageDice[index]
						if ( item.roll < 0 && !(index < damageDiceLength) ) { continue }
						damageRolled += diceRoll(item.die, item.roll || 1) * (item.scalar || 1)
						damageAdvantageRolled += diceRoll(item.die, item.roll || 1) * (item.scalar || 1)
					}
					
					hasHit = true
					
					if ( advantageDamage ) {
						damageRolled = Math.max(damageRolled, damageAdvantageRolled)
						if ( advantageDamage === 'once' ) { advantageDamage = 0 }
					}
					
					summary.push((isCritical ? "critical " : "") + "hit AC " + armorClass + " with " + toHit + (modifierHit > 0 ? "+" + modifierHit : modifierHit || "") + (hasAdvantage ? " (advantage)": "") + (hasDisadvantage ? " (disadvantage)": "") + " doing " + damageRolled + (damageModifier > 0 ? "+" + damageModifier : damageModifier || "") + " HP")
					
					effectiveness += Math.floor(damageRolled + damageModifier)
				}
				
				//console.log(summary)
				
				return effectiveness
			}
			
			function applyChanceToHit(r, i, j, p) {
				/*
					mmmmm mmmmm mmmmh hhhhc - no offense or defense
					mmmmm mmmmm mnnnh hhhhc - offense
					mmmmm mmmmm mmmmd dhhhc - defense
					mmmmm mmmmm mbbnh hhhhc - offense > defense
					mmmmm mmmmm mbbbd hhhhc - offense < defense
					
					m - 1     - miss
					n - 59    - hit once else miss
					d - 61    - miss once else hit
					b - 3599  - miss once else hit once else miss
					h - p > 1 - hit
					c - p > 1 - critical
				*/
				
				if ( j % 3599 === 0 ) {
					//	miss once consuming hit once
					j = !(i % 3599) ? 1 : !(i % 61) ? j / 61 : !(i % 59) ? 61 : j
				} else if ( j % 61 === 0 ) {
					//	miss once
					j = !(i % 61) ? j / 61 : 61
				} else if ( j % 59 === 0 ) {
					//	hit once
					j = !(i % 59) ? 1 : j
				}
				
				i *= j
				
				if ( r.keys.indexOf(i) < 0 ) {
					r.keys.push(i)
					r[i] = p
				} else {
					r[i] += p
				}
				
				r.sum += p
			}
			
			function multiplyChanceToHit(a, b) {
				var chances = new Object()
				var k = a.keys
				
				chances.keys = []
				chances.sum = 0
				
				if ( k && k.length > 0 ) {
					k.forEach(i => b.forEach((d, j) => applyChanceToHit(chances, i, j, a[i] * d)))
				} else {
					a.forEach((c, i) => b.forEach((d, j) => applyChanceToHit(chances, i, j, c * d)))
				}
				
				return chances
			}
			
			function removeOneTimeChancesFromChanceToHit(chances) {
				var r = []
				
				chances.forEach((p, i) => r[i / ((i % 59 ? 1 : 59) * (i % 61 ? 1 : 61))] = p + (r[i / ((i % 59 ? 1 : 59) * (i % 61 ? 1 : 61))] || 0))
				
				return r
			}
			
			function normalizeChanceToHit(chances) {
				var n = chances.sum
				
				if ( n > 0 ) {
					chances.keys.forEach(i => chances[i] /= n)
					chances.sum = 1
					
					return chances
				}
				
				n = 0
				chances.forEach(e => n += e)
				n = 1.0 / n
				
				return chances.map(e => e * n)
			}
			
			function evaluateOneChanceToHit(result, chance, damage, product, factor, index) {
				var once = !(result.once === product)
				var reduce = product
				var hits = 0, criticals = 0, sum
				var factorHit = damage.factorHit
				var factorCritical = damage.factorCritical
				
				while ( reduce % factorHit === 0 ) { hits += 1; reduce /= factorHit }
				while ( reduce % factorCritical === 0 ) { criticals += 1; reduce /= factorCritical }
				
				sum = hits + criticals
				
				if ( sum > 0 ) { result.once = product }
				if ( hits > 0 ) { result.damage += chance * hits * ((once ? damage.onceDamage - damage.manyDamage : 0) / sum + damage.manyDamage) }
				if ( criticals > 0 ) { result.damage += chance * criticals * ((once ? damage.onceCritical - damage.manyCritical : 0) / sum + damage.manyCritical) }
				if ( criticals > 0 ) { result.chanceToCritical += chance * criticals }
			}
			
			function evaluateChanceToHit(chances, damage) {
				var result = new Object()
				var n = 0
				
				result.once = 0
				result.damage = 0
				result.chanceToCritical = 0
				
				chances.forEach((p, i) => damage.forEach((d, j) => evaluateOneChanceToHit(result, p, d, i, j, ++n)))
				
				delete result.once
				
				return result
			}
			
			function chanceToHitProduct(a, b) {
				var r = []
				
				//	1=miss, 3=near, 5=hit, 7=critical
				//	i*j%9?i*j:i*j/3 converts second near miss to true miss
				a.forEach((e, i) => b.forEach((f, j) => r[i*j%49?i*j:i*j/7] = e*f + (r[i*j%49?i*j:i*j/7] || 0)))
				
				return r
			}
			
			function chanceToHitResolveNearMisses(p) {
				var r = []
				
				//	1=miss, 7=near, 3=hit, 5=critical
				//	i%3?i:i*5/3 converts single near miss to hit
				p.forEach((e, i) => r[i%7?i:i*3/7] = e + (r[i%7?i:i*3/7] || 0))
				
				return r
			}
			
			function chanceToHitNormalize(p) {
				var n = 0
				
				p.forEach(e => n += e)
				
				return p.map(e => e / n)
			}
			
			function evaluateAverageDamage(e) {
				var advantageDamage = e.advantageDamage, advantageDamageOnceAdjustment = 0
				var onceDiceDamage = 0, manyDiceDamage = 0
				var onceModifyDamage = 0, manyModifyDamage = 0
				var onceReduceDamage = 0, manyReduceDamage = 0
				var onceDice = 0, manyDice = 0
				var onceDiceCombination = [1], manyDiceCombination = [1]
				var onceDamage = 0, manyDamage = 0
				var onceCritical = 0, manyCritical = 0
				var onceDieCritical = 0, manyDieCritical = 0
				var index, item, roll, value, damageScalar, onceDamageScalar
				var immune, resistant, vulnerable, itemDamage
				var immuneAll = (e.immune && e.immune['all']) || false
				var resistantAll = (e.resistant && e.resistant['all']) || false
				var vulnerableAll = (e.vulnerable && e.vulnerable['all']) || false
				var type, previousType = false
				var criticalDice = e.criticalDice || 0
				var criticalDamage = e.criticalDamage || 0
				
				immuneAll = immuneAll ? immuneAll !== 'once' ? 2 : 1 : 0
				resistantAll = resistantAll ? resistantAll !== 'once' ? 2 : 1 : 0
				vulnerableAll = vulnerableAll ? vulnerableAll !== 'once' ? 2 : 1 : 0
				
				for ( index = 0 ; index < e.damage.length ; ++index ) {
					item = e.damage[index]
					roll = item.roll || 1
					type = item.type || previousType
					previousType = type
					damageScalar = 1
					onceDamageScalar = 0
					
					if ( roll < 0 ) {
						//if ( trace ) { console.log("Average reduce" + (item.die ? (roll < 0 ? ' ' : ' +') + roll + 'd' + item.die : '') + (item.modifier ? (item.modifier < 0 ? ' ' : ' +') + item.modifier : '') + (item.once ? 'o' : '')) }
						
						if ( item.once ) {
							if ( item.die > 0 ) { onceReduceDamage += -roll * (1 + item.die) / 2 }
							if ( item.modifier ) { onceReduceDamage += item.modifier }
						} else {
							if ( item.die > 0 ) { manyReduceDamage += -roll * (1 + item.die) / 2 }
							if ( item.modifier ) { manyReduceDamage += item.modifier }
						}
						
						continue
					}
					
					immune = type && damageTypeApplies(type, e.magical) && e.immune && e.immune[type]
					resistant = type && damageTypeApplies(type, e.magical) && e.resistant && e.resistant[type]
					vulnerable = type && e.vulnerable && e.vulnerable[type]
					
					immune = (immune ? immune !== 'once' ? 2 : 1 : 0) | immuneAll
					resistant = (resistant ? resistant !== 'once' ? 2 : 1 : 0) | resistantAll
					vulnerable = (vulnerable ? vulnerable !== 'once' ? 2 : 1 : 0) | vulnerableAll
					
					//if ( trace ) { console.log("Average damage" + (item.die ? (roll < 0 ? ' ' : ' +') + roll + 'd' + item.die : '') + (item.modifier ? (item.modifier < 0 ? ' ' : ' +') + item.modifier : '') + (item.once ? 'o' : '') + (type ? ' ' + type : '') + (immune ? ' i' + immune : '') + (resistant ? ' r' + resistant : '') + (vulnerable ? ' v' + vulnerable : '')) }
					
					if ( item.once ) {
						if ( immune ) { continue }
						if ( resistant ) { damageScalar = 0.5 }
						if ( vulnerable ) { damageScalar *= 2.0 }
						
						if ( item.die > 0 && advantageDamage ) {
							//	Approximate the effects of resistance and vulnerability combined with advantage on damage by scaling the die rolled
							onceDiceCombination = multiply(diceCombinations(item.die * damageScalar, roll), onceDiceCombination)
							onceDice += roll
						}
						
						if ( item.die > 0 ) { onceDiceDamage += damageScalar * roll * (1 + item.die) / 2 }
						if ( item.modifier ) { onceModifyDamage += damageScalar * item.modifier }
						if ( item.die > 0 && !onceDieCritical ) { onceDieCritical = item.die }
					} else {
						if ( immune > 1 ) { continue }
						if ( resistant > 1 ) { damageScalar = 0.5; onceDamageScalar = vulnerable === 1 ? 0.5 : 0 }
						if ( vulnerable > 1 ) { damageScalar *= 2.0; onceDamageScalar = resistant === 1 ? -1 : 0 }
						
						if ( immune === 1 ) { onceDamageScalar = -1 }
						if ( resistant === 1 && !vulnerable ) { onceDamageScalar = -0.5 }
						if ( vulnerable === 1 && !resistant ) { onceDamageScalar = 1 }
						
						if ( item.die > 0 && advantageDamage ) {
							//	Approximate the effects of resistance and vulnerability combined with advantage on damage by scaling the die rolled
							manyDiceCombination = multiply(diceCombinations(item.die * damageScalar, roll), manyDiceCombination)
							manyDice += roll
							
							if ( onceDamageScalar > 0 ) {
								onceDiceCombination = multiply(diceCombinations(item.die * onceDamageScalar, roll), onceDiceCombination)
								onceDice += roll
							}
							
							if ( onceDamageScalar < 0 ) {
								advantageDamageOnceAdjustment += onceDamageScalar * roll * (1 + item.die) / 2
							}
						}
						
						if ( item.die > 0 ) {
							manyDiceDamage += damageScalar * roll * (1 + item.die) / 2
							onceDiceDamage += onceDamageScalar * roll * (1 + item.die) / 2
						}
						
						if ( item.modifier ) {
							manyModifyDamage += damageScalar * item.modifier
							onceModifyDamage += onceDamageScalar * item.modifier
						}
						
						if ( item.die > 0 && !manyDieCritical ) { manyDieCritical = item.die }
					}
				}
				
				for ( index = 0 ; index < e.reduction.length ; ++index ) {
					item = e.reduction[index]
					roll = item.roll || 1
					
					if ( item.once ) {
						if ( item.die ) { onceReduceDamage += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { onceReduceDamage += item.modifier }
					} else {
						if ( item.die ) { manyReduceDamage += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { manyReduceDamage += item.modifier }
					}
					
					//if ( trace ) { console.log("Average reduce" + (item.die ? (roll < 0 ? ' ' : ' +') + roll + 'd' + item.die : '') + (item.modifier ? (item.modifier < 0 ? ' ' : ' +') + item.modifier : '') + (item.once ? 'o' : '')) }
				}
				
				onceDiceDamage += manyDiceDamage
				onceModifyDamage += manyModifyDamage
				onceReduceDamage += manyReduceDamage
				
				if ( onceDieCritical < manyDieCritical ) { onceDieCritical = manyDieCritical }
				manyCritical = manyDiceDamage * 2 + criticalDice * (manyDieCritical + 1) / 2
				onceCritical = onceDiceDamage * 2 + criticalDice * (onceDieCritical + 1) / 2
				
				if ( advantageDamage ) {
					//if ( trace ) { console.log("Average damage normal 1 x " + onceDiceDamage.toFixed(1) + " (c" + onceCritical.toFixed(1) + ")") }
					
					onceDice += manyDice
					onceDiceCombination = multiply(onceDiceCombination, manyDiceCombination)
					onceDiceDamage = advantageAverageForDiceCombinations(onceDiceCombination, onceDice)
					onceDiceDamage += advantageDamageOnceAdjustment
					
					onceDiceCombination = multiply(onceDiceCombination, onceDiceCombination)
					if ( criticalDice > 0 ) { onceDiceCombination = multiply(onceDiceCombination, diceCombinations(onceDieCritical, criticalDice)) }
					onceCritical = advantageAverageForDiceCombinations(onceDiceCombination, onceDice * 2 + criticalDice)
					onceCritical += advantageDamageOnceAdjustment * 2
					
					//if ( trace ) { console.log("Average damage advantage 1 x " + onceDiceDamage.toFixed(1) + " (c" + onceCritical.toFixed(1) + ")") }
					
					if ( advantageDamage !== 'once' ) {
						//if ( trace ) { console.log("Average damage normal " + (e.attacks - 1) + " x " + manyDiceDamage.toFixed(1) + " (c" + manyCritical.toFixed(1) + ")") }
						
						manyDiceDamage = advantageAverageForDiceCombinations(manyDiceCombination, manyDice)
						
						manyDiceCombination = multiply(manyDiceCombination, manyDiceCombination)
						if ( criticalDice > 0 ) { manyDiceCombination = multiply(manyDiceCombination, diceCombinations(manyDieCritical, criticalDice)) }
						manyCritical = advantageAverageForDiceCombinations(manyDiceCombination, manyDice * 2 + criticalDice)
						
						//if ( trace ) { console.log("Average damage advantage " + (e.attacks - 1) + " x " + manyDiceDamage.toFixed(1) + " (c" + manyCritical.toFixed(1) + ")") }
					}
				}
				
				manyDamage = manyDiceDamage + manyModifyDamage - manyReduceDamage
				onceDamage = onceDiceDamage + onceModifyDamage - onceReduceDamage
				manyCritical += manyModifyDamage - manyReduceDamage
				onceCritical += onceModifyDamage - onceReduceDamage
				manyCritical += criticalDamage
				onceCritical += criticalDamage
				
				//if ( trace ) { console.log("Average damage 1 x " + onceDamage.toFixed(1) + " (c" + onceCritical.toFixed(1) + ") + " + (e.attacks - 1) + " x " + manyDamage.toFixed(1) + " (c" + manyCritical.toFixed(1) + (e.criticalDice ? ' ' + e.criticalDice + 'd' + manyDieCritical : '') + ")") }
				
				if ( manyDamage < 0 ) { manyDamage = 0 }
				if ( onceDamage < 0 ) { onceDamage = 0 }
				if ( manyCritical < 0 ) { manyCritical = 0 }
				if ( onceCritical < 0 ) { onceCritical = 0 }
				
				return {
					'damage':manyDamage,
					'critical':manyCritical,
					'onceDamage':onceDamage,
					'onceCritical':onceCritical
				}
			}
			
			function computeSingleAverageEffectiveness(e) {
				if ( e.attacks < 0 || !e.damage ) {
					return 0
				}
				
				var averageDamage = evaluateAverageDamage(e)
				
				manyDamage = averageDamage.damage
				onceDamage = averageDamage.onceDamage
				manyCritical = averageDamage.critical
				onceCritical = averageDamage.onceCritical
				
				var trace = true
				var attacks = Math.max(+e.attacks, 1)
				var armorClass = e.armorClass || 10
				var onceArmorClass = 0, manyArmorClass = 0
				var onceModifierHit = 0, oncePenaltyHit = 0, manyModifierHit = 0
				var onceChanceToHit, manyChanceToHit, chanceToHit
				var toHit, toCritical, toNearlyMiss, toMiss, toLimit
				var h, c, hi, ci, p
				
				if ( e.armorClass === 0 ) { return onceDamage + (attacks - 1) * manyDamage }
				if ( e.armorClass === 99 ) { return onceCritical + (attacks - 1) * manyCritical }
				
				for ( index = 0 ; index < e.hit.length ; ++index ) {
					item = e.hit[index]
					roll = item.roll || 1
					
					if ( item.once ) {
						if ( item.die > 0 && roll > 0 ) { onceModifierHit += roll * (1 + item.die) / 2 }
						if ( item.die > 0 && roll < 0 ) { oncePenaltyHit += roll * (1 + item.die) / 2 }
						if ( item.modifier > 0 ) { onceModifierHit += item.modifier }
						if ( item.modifier < 0 ) { oncePenaltyHit += item.modifier }
					} else {
						if ( item.die ) { manyModifierHit += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { manyModifierHit += item.modifier }
					}
				}
				
				for ( index = 0 ; index < e.defense.length ; ++index ) {
					item = e.defense[index]
					roll = item.roll || 1
					
					if ( item.once ) {
						if ( item.die ) { onceArmorClass += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { onceArmorClass += item.modifier }
					} else if ( item.afterFirst ) {
						if ( item.die ) { manyArmorClass += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { manyArmorClass += item.modifier }
					} else {
						if ( item.die ) { armorClass += roll * (1 + item.die) / 2 }
						if ( item.modifier ) { armorClass += item.modifier }
					}
				}
				
				toLimit = 20
				toHit = Math.min(Math.max(2, armorClass + onceArmorClass - manyModifierHit - oncePenaltyHit), 20) - 1
				toCritical = Math.min(Math.max(toHit + 1, e.criticalRoll || 20), 20) - 1
				toNearlyMiss = Math.min(Math.max(1, toHit - onceModifierHit), 19)
				
				if ( e.advantageHit && !e.disadvantageHit ) {
					toLimit = 400
					toHit = toHit * toHit
					toCritical = toCritical * toCritical
					toNearlyMiss = toNearlyMiss * toNearlyMiss
				}
				
				if ( e.disadvantageHit && !e.advantageHit ) {
					toLimit = 400
					toHit = 400 - (20 - toHit) * (20 - toHit)
					toCritical = 400 - (20 - toCritical) * (20 - toCritical)
					toNearlyMiss = 400 - (20 - toNearlyMiss) * (20 - toNearlyMiss)
				}
				
				//	TODO: onceArmorClass should apply strategically instead of always with the first attack
				onceChanceToHit = [,toNearlyMiss,,toCritical - toHit,,toLimit - toCritical,,toHit - toNearlyMiss]
				
				toLimit = 20
				toHit = Math.min(Math.max(2, armorClass + manyArmorClass - manyModifierHit), 20) - 1
				toCritical = Math.min(Math.max(toHit + 1, e.criticalRoll || 20), 20) - 1
				toNearlyMiss = Math.min(Math.max(1, toHit - onceModifierHit), 19)
				
				if ( (e.advantageHit && e.advantageHit !== 'once') && !(e.disadvantageHit && e.disadvantageHit !== 'once') ) {
					toLimit = 400
					toHit = toHit * toHit
					toCritical = toCritical * toCritical
					toNearlyMiss = toNearlyMiss * toNearlyMiss
				}
				
				if ( (e.disadvantageHit && e.disadvantageHit !== 'once') && !(e.advantageHit && e.advantageHit !== 'once') ) {
					if ( e.disadvantageHit === 'hit' ) {
						// Approximate the effects of having disadvantage until a hit is scored by applying fractional disadvantage
						var power = 1 + (onceChanceToHit[1] / 400)
						
						for ( index = 2 ; index < attacks ; ++index ) {
							power = 1 + (power - 1) * (1 - Math.pow((20 - toNearlyMiss) / 20, power))
						}
						
						toLimit = 1
						toHit = toLimit - Math.pow((20 - toHit) / 20, power)
						toCritical = toLimit - Math.pow((20 - toCritical) / 20, power)
						toNearlyMiss = toLimit - Math.pow((20 - toNearlyMiss) / 20, power)
					} else {
						toLimit = 400
						toHit = 400 - (20 - toHit) * (20 - toHit)
						toCritical = 400 - (20 - toCritical) * (20 - toCritical)
						toNearlyMiss = 400 - (20 - toNearlyMiss) * (20 - toNearlyMiss)
					}
				}
				
				manyChanceToHit = [,toNearlyMiss,,toCritical - toHit,,toLimit - toCritical,,toHit - toNearlyMiss]
				
				//if ( trace ) { console.log("Average hit 1 x " + (onceChanceToHit[3] + onceChanceToHit[5] + onceChanceToHit[7]).toFixed(2) + " : " + onceChanceToHit[1].toFixed(2) + " + " + (attacks - 1) + " x " + (manyChanceToHit[3] + manyChanceToHit[5] + manyChanceToHit[7]).toFixed(2) + " : " + manyChanceToHit[1].toFixed(2)) }
				
				chanceToHit = onceChanceToHit
				chanceToCritical = 0
				damage = 0
				
				if ( attacks > 6 ) {
					damage += (attacks - 6) * manyChanceToHit[3] * manyDamage / toLimit
					damage += (attacks - 6) * manyChanceToHit[5] * manyCritical / toLimit
					chanceToCritical += (attacks - 6) * manyChanceToHit[5]
					attacks = 6
				}
				
				for ( index = 1 ; index < attacks ; ++index ) {
					chanceToHit = chanceToHitProduct(chanceToHit, manyChanceToHit)
				}
				
				chanceToHit = chanceToHitResolveNearMisses(chanceToHit)
				chanceToHit = chanceToHitNormalize(chanceToHit)
				
				for ( h = 0, hi = 1 ; h <= attacks ; ++h, hi *= 3 ) {
					for ( c = 0, ci = 1 ; h + c <= attacks ; ++c, ci *= 5 ) {
						p = chanceToHit[hi * ci] || 0
						
						if ( h > 0 ) { damage += p * h * ((onceDamage - manyDamage) / (h + c) + manyDamage) }
						if ( c > 0 ) { damage += p * c * ((onceCritical - manyCritical) / (h + c) + manyCritical) }
						if ( c > 0 ) { chanceToCritical += p }
					}
				}
				
				if ( e.criticalBonusAttack ) {
					if ( chanceToCritical > 1 ) { chanceToCritical = 1 }
					
					damage += chanceToCritical * manyChanceToHit[3] * manyDamage / toLimit
					damage += chanceToCritical * manyChanceToHit[5] * manyCritical / toLimit
				}
				
				return damage
			}
			
			function parseEffectiveness(string) {
				var parts = string.split(';')
				var index, count = parts.length
				
				// use defense from last part as default defense for all parts
				if ( count > 1 ) {
					var defense = parts[count - 1].indexOf('@')
					
					if ( defense >= 0 ) {
						var suffix = parts[count - 1].slice(defense)
						
						for ( index = 0 ; index < count - 1 ; ++index ) {
							if ( parts.length > 0 && parts[index].indexOf('@') < 0 ) {
								parts[index] += suffix
							}
						}
					}
				}
				
				return parts.map(parseSingleEffectiveness)
			}
			
			function computeAverageEffectiveness(e) {
				return e.map(computeSingleAverageEffectiveness).reduce((s, e) => s+e, 0)
			}
			
			function computeRandomEffectiveness(e) {
				return e.map(computeSingleRandomEffectiveness).reduce((s, e) => s+e, 0)
			}
			
			function experiment() {
			}
			
			function handleChanceToHit(event) {
				var input = document.getElementById('chance-to-hit-input')
				var output = document.getElementById('chance-to-hit-text')
				if ( !input.value ) { output.innerHTML = ""; return }
				
				experiment()
				
				var armorClass = Math.max(+input.value, 0)
				if ( !armorClass ) { return }
				
				var chanceToHit = (21 - Math.min(Math.max(2, armorClass), 20)) / 20
				var chanceToCritical = (21 - Math.min(Math.max(20, armorClass), 20)) / 20
				var advantageChanceToHit = 1 - (1 - chanceToHit) * (1 - chanceToHit)
				var disadvantageChanceToHit = chanceToHit * chanceToHit
				
				output.innerHTML = "Chance " + (chanceToHit * 100).toFixed(1) + "%" +
					", with advantage " + (advantageChanceToHit * 100).toFixed(1) + "%" + " (+" + Math.round((advantageChanceToHit - chanceToHit) * 20) + ")" +
					", with disadvantage " + (disadvantageChanceToHit * 100).toFixed(1) + "%" + " (-" + Math.round((chanceToHit - disadvantageChanceToHit) * 20) + ")"
			}
			
			function handleAdvantage(event) {
				var input = document.getElementById('advantage-input')
				var output = document.getElementById('advantage-text')
				if ( !input.value ) { output.innerHTML = ""; return }
				
				var matched = input.value.match(/\d*d\d+/g)
				if ( !(matched && matched.length > 0) ) { return }
				
				var rolling = ""
				var dc = [1]
				var dice = 0
				var die, roll
				var average = 0
				var maximum = 0
				
				for ( match of matched ) {
					var s = match.split("d")
					
					roll = s.length > 1 ? +s[0] : 0
					die = s.length > 1 ? +s[1] : +s[0]
					if ( !( die > 1 ) ) { continue }
					if ( !( roll > 1 ) ) { roll = 1 }
					
					dc = multiply(dc, diceCombinations(die, roll))
					dice += roll
					maximum += roll * die
					average += roll * (die + 1) / 2
					rolling += roll + "d" + die + " "
				}
				
				var advantage = advantageAverageForDiceCombinations(dc, dice)
				
				output.innerHTML = dice + "-" + maximum + " average " + average.toFixed(2) +
					", with advantage " + advantage.toFixed(2) +
					", with disadvantage " + (average * 2 - advantage).toFixed(2)
			}
			
			function handleEffectiveness(event) {
				var input = document.getElementById('effectiveness-input')
				var output = document.getElementById('effectiveness-text')
				if ( !input.value ) { output.innerHTML = ""; return }
				
				var parsed = parseEffectiveness(input.value)
				if ( !parsed.length && !parsed[0].damage.length ) { return }
				
				var effectiveness = computeAverageEffectiveness(parsed)
				var rolled, index, sum = 0, samples = 10
				var example = []
				
				for ( index = 0 ; index < samples ; ++index ) {
					rolled = computeRandomEffectiveness(parsed)
					example.push(rolled)
					sum += rolled
				}
				
				var montecarlo = Math.max(samples, 1000)
				for ( index = 0 ; index < montecarlo - samples ; ++index ) {
					rolled = computeRandomEffectiveness(parsed)
					sum += rolled
				}
				
				output.innerHTML = "Average damage per turn: " + effectiveness.toFixed(2) + " (e.g. " + (sum / montecarlo).toFixed(2) + " with " + example.join(", ") + ")"
			}
		</script>
	</head>
	<body>
		<h4>Attack Effectiveness</h4>
		
		<span id='effectiveness-description' class='tiny'>hit / damage # attacks @ target</span><br/>
		<input type='text' id='effectiveness-input' name='effectiveness' size='60' placeholder='+5 /d8+3s #2 @ 16' oninput='handleEffectiveness(event)'>
		<p><span id='effectiveness-text'></span></p>
		
		<input id='toggle-attack-examples' type='checkbox' class='toggle'/>
		<label for='toggle-attack-examples' class='toggle'>Examples</label>
		<table id='attack-examples' class='toggled'>
			<tr><td>Default Armor Class</td><td>@10</td><td>Target has AC 10</td></tr>
			<tr><td>Default Attacks</td><td>#1</td><td>Attack 1 time</td></tr>
			<tr><td>Proficiency Bonus</td><td>+2</td><td>Hit +2</td></tr>
			<tr><td>Ability Bonus</td><td>+3/+3</td><td>Hit and Damage +3</td></tr>
			<tr><td>Dwarf: Dwarven Resilience</td><td>@ rq</td><td>Resistant to poison damage</td></tr>
			<!-- tr><td>Halfling: Lucky</td><td>r1</td><td>(not implemented) Reroll attack dice up to 1</td></tr -->
			<tr><td>Half Orc: Savage Attacks</td><td>/ +c1d</td><td>Add 1 die to critical damage</td></tr>
			<tr><td>Barbarian: Rage</td><td>/ +2 @ rbps</td><td>Damage +2</td></tr>
			<tr><td>Barbarian: Reckless Attack</td><td>a @ a</td><td>Advantage to hit</td></tr>
			<tr><td>Barbarian: Bear Totem</td><td>@ rabcefnpqrst</td><td>Resist damage except psychic (y)</td></tr>
			<tr><td>Barbarian: Brutal Critical</td><td>/ +c1d</td><td>Add 1 die to critical damage</td></tr>
			<tr><td>Bard: Bardic Inspiration</td><td>+d6o</td><td>Hit +1d6 one time</td></tr>
			<tr><td>Cleric: Potent Spellcasting</td><td>/ +5</td><td>Damage +5</td></tr>
			<tr><td>Cleric: Divine Strike</td><td>/ +d8ro</td><td>Damage +d8 radiant</td></tr>
			<tr><td>Cleric: Avatar of Battle</td><td>@ rbps</td><td>Resist bludgeoning, piercing and slashing damage</td></tr>
			<tr><td>Fighter: Extra Attack</td><td>#2</td><td>Attack 2 times</td></tr>
			<tr><td>Champion: Improved Critical</td><td>c19</td><td>Critical damage on 19 or higher</td></tr>
			<tr><td>Champion: Superior Critical</td><td>c18</td><td>Critical damage on 18 or higher</td></tr>
			<tr><td>Battle Master: Lunge</td><td>/ +d8</td><td>Damage +d8</td></tr>
			<tr><td>Battle Master: Precision</td><td>+d8</td><td>Hit +d8</td></tr>
			<tr><td>Battle Master: Parry</td><td>@ -d8o-3o</td><td>Reduce damage by d8+3 one time</td></tr>
			<tr><td>Monk: Deflect Missile</td><td>@ -d10o-5o</td><td>Reduce damage by d8+5 one time</td></tr>
			<tr><td>Monk: Shadow Step</td><td>ao</td><td>Advantage to hit one time</td></tr>
			<tr><td>Monk: Purity of Body</td><td>@ iq</td><td>Immune to poison damage</td></tr>
			<tr><td>Paladin: Improved Divine Smite</td><td>/ +d8r</td><td>Damage +d8 radiant</td></tr>
			<tr><td>Ranger: Foe Slayer</td><td>+5o</td><td>Hit +5 one time</td></tr>
			<tr><td>Ranger: Colossus Slayer</td><td>/ +d8o</td><td>Damage +d8 one time</td></tr>
			<tr><td>Ranger: Multiattack Defense</td><td>@ +4m</td><td>Armor class +4 after first hit</td></tr>
			<tr><td>Rogue: Sneak Attack</td><td>/ +2d6o</td><td>Damage +2d6 one time</td></tr>
			<tr><td>Rogue: Uncanny Dodge</td><td>@ ro</td><td>Resist all damage one time</td></tr>
			<tr><td>Rogue: Assassinate</td><td>a c1</td><td>Advantage to hit, Critical damage on any roll</td></tr>
			<tr><td>Rogue: Versatile Trickster</td><td>a</td><td>Advantage to hit</td></tr>
			<tr><td>Warlock: Lifedrinker</td><td>/ +3</td><td>Damage +3</td></tr>
			<tr><td>Sorcerer: Elemental Affinity</td><td>/ +3</td><td>Damage +3</td></tr>
			<tr><td>Fighting Style: Archery</td><td>+2</td><td>Hit +2</td></tr>
			<tr><td>Fighting Style: Defense</td><td>@ +1</td><td>Armor Class +1</td></tr>
			<tr><td>Fighting Style: Dueling</td><td>/ +2</td><td>Damage +2</td></tr>
			<!-- tr><td>Fighting Style: Great Weapon Fighting</td><td>/ r2</td><td>(not implemented) Reroll damage dice up to 2</td></tr -->
			<tr><td>Feat: Charger</td><td>/ +5</td><td>Damage +5</td></tr>
			<tr><td>Feat: Dual Wielder</td><td>@ +1</td><td>Armor Class +1</td></tr>
			<tr><td>Feat: Great Weapon Master</td><td>-5/+10#cb</td><td>Hit -5, damage +10, bonus attack after critical hit</td></tr>
			<tr><td>Feat: Heavy Armor Master</td><td>@ -3</td><td>Target reduces damage by 3</td></tr>
			<tr><td>Feat: Savage Attacker</td><td>/ ao</td><td>Advantage on damage one time</td></tr>
			<tr><td>Feat: Sharpshooter</td><td>-5/+10</td><td>Hit -5, damage +10</td></tr>
			<tr><td>Spell: Bane</td><td>-d4</td><td>Hit -d4</td></tr>
			<tr><td>Spell: Bless</td><td>+d4</td><td>Hit +d4</td></tr>
			<tr><td>Spell: Foresight</td><td>a @ d</td><td>Advantage on hit, attackers have disadvantage</td></tr>
			<tr><td>Spell: Haste</td><td>#2 @ +2</td><td>Attack one more time, Armor class +2</td></tr>
			<tr><td>Spell: Hex</td><td>/ +d6n</td><td>Damage +d6 necrotic</td></tr>
			<tr><td>Spell: Invisibility</td><td>ao</td><td>Advantage on hit one time</td></tr>
			<tr><td>Spell: Stoneskin</td><td>@ rbps</td><td>Resist bludgeoning, piercing and slashing damage</td></tr>
			<tr><td>Item: Bracers of Archery</td><td>/ +2</td><td>Damage +2</td></tr>
			<tr><td>Item: Bracers of Defense</td><td>@ +2</td><td>Armor Class +2</td></tr>
			<tr><td>Item: Cloak of Displacement</td><td>@ dh</td><td>Attackers have disadvantage until hit</td></tr>
			<tr><td>Item: Dwarven Thrower</td><td>+3m/d8b+d8b+3</td><td>Hit +3, damage 2d8+3</td></tr>
			<tr><td>Item: Magic Weapon</td><td>+3m/+3</td><td>Hit and damage +3, attack is magical</td></tr>
			<tr><td>Item: Sword of Sharpness</td><td>+1m/+1+c14</td><td>Hit and damage +1, critical damage +14</td></tr>
			<tr><td>Fighter 1: Longsword</td><td class='character'>+2+3/d8s+3#1@13</td><td>Hit +5, damage d8+3, 1 attack, target AC 13</td></tr>
			<tr><td>Warlock 20: Wand +3, Hex</td><td class='character'>+6+5+3/d10e+5+d6n#4</td><td>Hit +14, damage d10+d6+5, 4 attacks</td></tr>
			<tr><td>Champion 20: Greatsword +3</td><td class='character'>c18+6+5+3m-5/2d6s+3+5+10#4cb</td><td>Hit +9, critical on 18, damage 2d6+18, 4 attacks, bonus attack on critical</td></tr>
			<tr><td>Battle Master 20: Longbow +3, Bracers</td><td class='character'>+6+5+3m+2-5+d12o/d8p+3+5+2+10#4</td><td>Hit +11, +d12 one time, damage d8 + 20, 4 attacks</td></tr>
			<tr><td>Barbarian 20: Greataxe +3</td><td class='character'>+6+7+3m-5/d12s+3+7+10+4+c4d#2cb</td><td>Hit +11, damage d12+24, critical +4 dice, 2 attacks, bonus attack on critical</td></tr>
			<tr><td>Assassin 20: Shortbow +3, surprise</td><td class='character'>c1a+6+5+3m/d6p+3+5+10d6o#1</td><td>Hit +14, critical on 1, advantage, damage d6+8, +10d6 once</td></tr>
			<tr><td colspan=3/></td></tr>
		</table>
		
		<p>
			<hr/>
			Chance to hit AC: <input type='number' id='chance-to-hit-input' name='advantage' size='40' placeholder='16' oninput='handleChanceToHit(event)'><br/>
			<span id='chance-to-hit-text'> </span>
		</p>
		
		<p>
			<hr/>
			Average of die roll: <input type='text' id='advantage-input' name='advantage' size='40' placeholder='4d6' oninput='handleAdvantage(event)'><br/>
			<span id='advantage-text'> </span>
		</p>
		
		<p>
			<hr/>
			
			<span class='tiny'>Some calculations are approximated.  With advantage on damage, resistance and vulnerability are approximate.  Disadvantage on attack until a hit succeeds is approximated.  One time defense options are applied to the first attack instead of strategically.</span>
		</p>
	</body>
</html>
