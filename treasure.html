<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Treasure</title>
		<meta name="author" content="Cole">
		<meta name="keywords" content="dnd,5e,dungeons,dragons,treasure">
		<meta name="description" content="Treasure">
		<script src="data/treasure.js"></script>
		<script src="src/treasure.js"></script>
		
		<script type="text/javascript">
			'use strict';
			
			function _element(id) {
				if ( id && Node.ELEMENT_NODE === id.nodeType ) return id;
				else if ( 'body' === id || 'head' === id ) return document[id];
				else return document.getElementById(id);
			}
			
			function _assignClass(element, c) {
				var result = 0;
				var action = ( arguments.length > 2 ) ? arguments[2] || 0 : 1
				
				if ( element.classList && 'function' === typeof element.classList.contains ) {
					if ( !(action > 0 || action < 0) ) {
						result = element.classList.toggle(c) ? 1 : -1
					} else if ( element.classList.contains(c) ) {
						result = !( action > 0 ) ? element.classList.remove(c) || -1 : 0
					} else {
						result = !( action < 0 ) ? element.classList.add(c) || 1 : 0
					}
				} else if ( element.className && 'function' === typeof element.className.search ) {
					var pattern = new RegExp('(^|\\s+)'+c+'(\\s+|$)');
					
					if ( element.className.search(pattern) < 0 ) {
						if ( !(action < 0) ) {
							element.className = element.className !== "" ? element.className + " " + c : c
							result = 1
						}
					} else {
						if ( !(action > 0) ) {
							element.className = element.className.replace(pattern, " ").trim()
							result = -1
						}
					}
				} else if ( !(action < 0) ) {
					element.className = c
					result = 1
				}
				
				return result;
			}
			
			function inflateParameters(result, string, leading, separator) {
				if ( string.charAt(0) === leading ) { string = string.slice(1) }
				
				var part, parts = string.split(separator)
				var object = result || {}
				
				for ( part of parts ) {
					var equals = part.indexOf("=")
					var value = (equals < 0) ? true : decodeURIComponent(part.slice(equals + 1))
					var key = equals < 0 ? part : part.slice(0, equals)
					
					object[key] = value
				}
				
				return object
			}
			
			function stripDiacriticals(string) {
				if ( typeof string.normalize === 'function' ) {
					return string.normalize('NFD').replace(/[\u0300-\u036f]/g, "")
				} else {
					return string.replace('é', 'e')
				}
			}
			
			function referenceKey(name) {
				return stripDiacriticals(name.toLowerCase()).replace(/(['‘’(){}×.,:]+|[-+ \t]+|\ba\s|\bof\s|\bthe\s)/g, '')
			}
			
			function resolveReferences(text, object) {
				text = text.replace(/\{=([^{}]+)\}/g, function (match, list) {
					var part = list.split('/'), key = part[0], value = object[key]
					
					if ( value && part.length > 1 ) {
						switch ( part[1] ) {
						case 'l': value = value.toLocaleLowerCase(); break
						case 'u': value = value.toLocaleUpperCase(); break
						case 'a': value = "a"; break
						case 'at': value = "A"; break
						}
					}
					
					return "<span class='property " + key + "'>" + (value || '-') + "</span>"
				})
				
				text = text.replace(/\{@([^{} ]+)\s+([^{}]+)\}/g, function (match, type, list) {
					var part = list.split('|')
					
					switch ( type ) {
					case "h": return "<span class='entries hit italic'>Hit: " + list + "</span> "
					case "recharge": return "<span class='entries recharge'>" + list + "</span>"
					case "b": case "bold": return "<span class='entries bold'>" + list + "</span>"
					case "i": case "italic": return "<span class='entries italic'>" + list + "</span>"
					case "dice": case "damage": return "<span class='entries " + type + " italic' onclick='handleDice(event, \"" + part[0] + "\")'>" + (part[1] || part[0]) + "</span>"
					case "chance": return "<span class='entries " + type + "' onclick='handleChance(event, \"" + part[0] + "\")'>" + (part[1] || part[0] + " percent") + "</span>"
					case "link": return "<span class='entries " + type + " italic'>" + list + "</span>"
					case "hit": return (+list < 0 ? "" : "+") + list
					case "atk": return "<span class='entries attack italic'>" + list.replace(/./g, function (l) { return (["Ranged", "Melee", "Spell", "Weapon", "or"]["rmsw,".indexOf(l)] || l) + " " }) + " Attack:</span> "
					case "dc": return list
					case "item": return "<a class='entries item' href='items.html#" + referenceKey(part[0]) + "'>" + (part[2] || part[0]) + "</a>"
					case "spell": return "<a class='entries spell italic' href='spells.html#" + referenceKey(part[0]) + "'>" + (part[2] || part[0]) + "</a>"
					case "creature": return "<a class='entries creature' href='bestiary.html#" + referenceKey(part[0]) + "'>" + (part[2] || part[0]) + "</a>"
					case "condition": case "skill": case "sense": case "action": case "hazard": return "<span class='entries " + type + "'>" + part[0] + "</span>"
					case "filter": return (part.length > 2 && part[1] === 'spells') ? "<a class='entries spell italic' href='spells.html?" + part[2] + "'>" + part[0] + "</a>" : "<span class='entries italic " + type + "'>" + part[0] + "</span>"
					case "adventure": return "<span class='entries italic " + type + "'>" + part[0] + "</span>"
					case "table": return "<span class='entries italic " + type + "'>" + (part[2] || part[0]) + "</span>"
					case "book": return "<span class='entries italic " + type + "'>" + (part[3] || part[0]) + "</span>"
					default: return "<span class='entries italic " + type + "'>" + (part[2] || part[0]) + "</span>"
					}
				})
				
				text = text.replace(/\{@h\}/g, "<span class='entries hit italic'>Hit:</span> ")
				text = text.replace(/\{@recharge\}/g, "<span class='entries recharge'></span>")
				
				return text
			}
			
			function generateTreasuresForRequest(treasure, challenge, quantity, kind, raw) {
				if ( kind === 'player' ) {
					kind = 'party'
					quantity /= 4
				}
				
				switch ( kind ) {
				case 'hoard': return raw ? treasureRawHoard(treasure, challenge, quantity) : treasureColeHoard(treasure, challenge, quantity)
				case 'party': return raw ? treasureRawParty(treasure, challenge, quantity) : treasureColeParty(treasure, challenge, quantity)
				default:      return treasureIndividual(treasure, challenge, quantity); break;
				}
			}
			
			function generateTreasure() {
				var treasure = window.treasure
				var lookup = window.lookup
				var form = _element('treasure-form')
				var kind = form.kind.value
				var challenge = form.challenge.value
				var quantity = form.quantity.value || 1
				var partition = form.partition.checked
				var raw = form.raw.checked
				var treasures
				var descriptions
				
				if ( partition && quantity > 1 ) {
					treasures = []
					
					while ( quantity --> 0 ) {
						treasures = treasures.concat(generateTreasuresForRequest(treasure, challenge, 1, kind, raw))
						
						if ( quantity > 0 ) {
							treasures.push({'descriptions':["-"], 'summarize':true})
						}
					}
				} else {
					treasures = generateTreasuresForRequest(treasure, challenge, quantity, kind, raw)
				}
				
				treasureLookupItems(treasure, lookup, treasures)
				descriptions = treasureDescriptions(treasures, 'references')
				displayTreasure(treasure, descriptions)
			}
			
			function handleReroll(key, identifier) {
				var item = treasureLookupMagicItemKey(treasure, lookup, key.toLowerCase())
				
				_element(identifier).innerHTML = " " + resolveReferences(item.reference, item)
			}
			
			function displayTreasure(treasure, list) {
				var items
				var beginHTML = "<ul class='treasure'>"
				var closeHTML = "</ul>"
				var rulerHTML = "<hr />"
				var html
				
				if ( !treasureLookupItems.excludeMagicItemTable ) {
					var key, identifier, item, index, count = list.length
					
					items = []
					
					for ( index = 0 ; index < count ; ++index ) {
						item = list[index]
						key = item.slice(0, 1)
						
						if ( item === '-' ) {
							items.push(closeHTML + rulerHTML + beginHTML)
							continue
						}
						
						if ( item.slice(1, 2) === ':' && treasure.magic[key.toLowerCase()] ) {
							identifier = "item-" + (index + 1)
							item = "<span class='reroll' onclick='handleReroll(\"" + key + "\", \""+identifier+"\")'>" + key + ":</span><span id='" + identifier + "'>" + item.slice(2) + "</span>"
						}
						
						items.push("<li>" + item + "</li>")
					}
				} else {
					items = list.map(i => "<li>" + (i === '-' ? rulerHTML : i) + "</li>")
				}
				
				if ( items.length > 0 ) {
					html = beginHTML + items.join("") + closeHTML
					html = resolveReferences(html, treasure)
				} else {
					html = "<span class='faded'>No Treasure</span>"
				}
				
				_element('treasure-list').innerHTML = html
			}
			
			function applyParameters() {
				var hash = inflateParameters(null, location.hash, '#', '|')
				var object = inflateParameters(hash, location.search, '?', '&')
				var form = _element('treasure-form')
				var key, value
				
				value = object['k']
				if ( value ) {
					if ( value.startsWith('i') ) { form.kind.value = 'individual' }
					else if ( value.startsWith('play') ) { form.kind.value = 'player' }
					else if ( value.startsWith('p') ) { form.kind.value = 'party' }
					else { form.kind.value = 'hoard' }
				}
				
				value = parseFloat(object['c'] || object['challenge'] || object['level']) || 0
				if ( value > 0 ) { form.challenge.value = value }
				
				value = parseFloat(object['n'] || object['quantity']) || 0
				if ( value > 0 ) { form.quantity.value = value }
				
				value = parseFloat(object['w'] || object['weight']) || 0
				if ( value ) { treasureDefaults.minimumPoundsToDisplayWeight = value }
				
				value = (object['m'] || object['force'])
				if ( value && treasure.magic[value] ) { treasureDefaults.forceMagicItemTable = value }
				
				value = object['x']
				if ( value ) { treasureDefaults.excludeMagicItemTable = true }
				
				value = (object['p'] || object['partition'])
				if ( value ) { form.partition.checked = true }
				
				value = (object['r'] || object['raw'])
				if ( value ) { form.raw.checked = true }
			}
			
			function validateTreasure() {
				var magicTables = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'i-armor']
				var index, keys = treasure.items.map(i => i.key)
				var table, sum, weapon
				
				for ( table of treasure.hoard ) {
					sum = table.table.reduce((s, e) => s + e.frequency, 0)
					
					if ( sum != 100 ) {
						console.log("Incorrect frequency sum " + sum + " on individual table CR " + table.cr)
					}
				}
				
				for ( table of treasure.individual ) {
					sum = table.table.reduce((s, e) => s + e.frequency, 0)
					
					if ( sum != 100 ) {
						console.log("Incorrect frequency sum " + sum + " on hoard table CR " + table.cr)
					}
				}
				
				for ( table of magicTables ) {
					sum = treasure.magic[table].reduce((s, e) => s + e.frequency, 0)
					
					if ( sum != 100 && table.length == 1 ) {
						console.log("Incorrect frequency sum " + sum + " on magic table " + table)
					}
					
					for ( var entry of treasure.magic[table] ) {
						index = keys.indexOf(entry.item)
						if ( index >= 0 ) {
							keys.splice(index, 1)
						}
						
						//if ( !lookup.items[entry.name] ) {
						//	console.log("Missing item " + entry.item)
						//}
						if ( entry.armor && !lookup.armors[entry.armor] && !Array.isArray(entry.armor) ) {
							console.log("Missing armor " + entry.armor)
						}
						if ( entry.weapon ) {
							if ( Array.isArray(entry.weapon) ) {
								for ( weapon of entry.weapon ) {
									if ( !lookup.weapons[weapon.slice(weapon.indexOf(':') + 1)] ) {
										console.log("Missing weapon " + weapon)
									}
								}
							} else {
								if ( !lookup.weapons[entry.weapon] ) {
									console.log("Missing weapon " + entry.weapon)
								}
							}
						}
					}
				}
				
				for ( var key of keys ) {
					console.log("Unreferenced item " + key)
				}
			}
			
			function populateLookup() {
				var key, keys = ['armors', 'weapons']
				var value, valueByKey = new Object()
				
				for ( key of keys ) {
					valueByKey[key] = new Object()
					
					for ( value of treasure[key] ) { valueByKey[key][value.key] = value }
				}
				
				window.lookup = valueByKey
			}
			
			function populatePage() {
				populateLookup()
				applyParameters()
				generateTreasure()
			}
		</script>
		
		<style>
			html {
				background: #EEE;
			}
			
			body {
				-webkit-font-smoothing: antialiased;
				-webkit-touch-callout: none;
				color: #555;
				background: #FFF;
				font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
				font-size: 14px;
				line-height: 1.75;
				padding: 2em;
				margin: 0 auto;
				max-width: 50em;
			}
			
			html { background-image: linear-gradient(270deg, rgb(230, 233, 233) 0%, rgb(216, 221, 221) 100%); }
			body { position:relative; box-shadow: 0 0 0.125em rgba(0, 0, 0, 0.06); }
			
			p.explanation { font-size:80%; color:#999; }
			span.reroll { color:#123; cursor:pointer; }
			span.faded { color:#CCC; }
			
			a { color:inherit; text-decoration:none; }
			
			input.big-button { font-size:150%; border-radius:0.5em; border:3px solid #CCC; padding:0.5em 1.5em; background:#F8F8F8; margin:0 1em; }
			input.big-number { font-size:125%; }
			
			#treasure-list { font-size:125%; }
			#treasure-list ul { list-style-type:circle; list-style-position:outside; }
			
			@media (max-width:360px) {
				input.big-number { font-size:100%; }
				#treasure-list { font-size:100%; }
			}
			
			@media screen {
				input.treasure { background-image:linear-gradient(135deg, #EEB 0%, #FFD 70%, #FFF 100%); border-color:#642; color:#642; }
			}
			
			.nose, .reroll {
				-webkit-touch-callout:none;
				-webkit-user-select:none;
				-moz-user-select:none;
				-ms-user-select:none;
				-o-user-select:none;
				user-select:none;
			}
		</style>
	</head>
	<body onload='populatePage()'>
		<h4>Treasure</h4>
		
		<form id='treasure-form' onsubmit="generateTreasure(); return false">
		<select name='kind' id='treasure-kind' class='big-select' title='Type of treasure'>
			<option value="individual">Individual Treasure</option>
			<option value="hoard" selected>Treasure Hoard</option>
			<option value="party">Party Treasure</option>
			<option value="player">Player (&frac14; Party)</option>
		</select>
		<input name='challenge' id='treasure-challenge' type='number' value='4' min='0' max='30' class='big-number' title='Challenge rating or level' />
		&times; <input type='number' name='quantity' value='1' min='1' max='99' id='treasure-quantity' class='big-number' title='Number of times to roll' />
		<input type='submit' class='big-button treasure' value='Roll' title='Generate random treasure' />
		<input type='checkbox' name='partition' id='treasure-partition' title='Separate multiple rolls' /><label for='treasure-partition' class='nose'> &horbar;</label>
		<input type='checkbox' name='raw' id='treasure-raw' title='Rules as Written - do not mix rarity' /><label for='treasure-raw' class='nose'> RaW</label>
		</form>
		
		<p id='treasure-list'></p>
		<table id='treasure'></table>
		
		<p class='explanation'>RaW rolls from the DMG treasure hoard tables, choosing all items from the same magic item table.  The Cole method uses the same tables in a slightly different way to mix items of different rarity.</p>
	</body>
</html>
