<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Treasure</title>
		<meta name="author" content="Eric Cole">
		<meta name="version" content="0.5">
		<meta name="keywords" content="dnd,5e,dungeons,dragons,treasure">
		<meta name="description" content="Treasure">
		<script src="treasure.js"></script>
		
		<script lang="javascript">
			var defaults = {
				raw: false,
				times: " Ã— ",
				forceMagicItemTable: false,
				includeMagicItemTable: false,
				minimumPoundsToDisplayWeight: 20
			}
			
			function _element(id) {
				if ( id && Node.ELEMENT_NODE === id.nodeType ) return id;
				else if ( 'body' === id || 'head' === id ) return document[id];
				else return document.getElementById(id);
			}
			
			function _assignClass(element, c) {
				var result = 0;
				var action = ( arguments.length > 2 ) ? arguments[2] || 0 : 1
				
				if ( element.classList && 'function' === typeof element.classList.contains ) {
					if ( !(action > 0 || action < 0) ) {
						result = element.classList.toggle(c) ? 1 : -1
					} else if ( element.classList.contains(c) ) {
						result = !( action > 0 ) ? element.classList.remove(c) || -1 : 0
					} else {
						result = !( action < 0 ) ? element.classList.add(c) || 1 : 0
					}
				} else if ( element.className && 'function' === typeof element.className.search ) {
					var pattern = new RegExp('(^|\\s+)'+c+'(\\s+|$)');
					
					if ( element.className.search(pattern) < 0 ) {
						if ( !(action < 0) ) {
							element.className = element.className !== "" ? element.className + " " + c : c
							result = 1
						}
					} else {
						if ( !(action > 0) ) {
							element.className = element.className.replace(pattern, " ").trim()
							result = -1
						}
					}
				} else if ( !(action < 0) ) {
					element.className = c
					result = 1
				}
				
				return result;
			}
			
			function coalesceArrayElements(array) {
				var result = []
				var count, counts = new Object()
				var element
				
				for ( element of array ) {
					counts[element] = (counts[element] || 0) + 1
				}
				
				for ( element of array ) {
					if ( counts[element] > 1 ) { result.push(element + defaults.times + counts[element]) }
					else if ( counts[element] > 0 ) { result.push(element) }
					else { continue }
					
					delete counts[element]
				}
				
				return result
			}
			
			function randomInteger(count) {
				if ( crypto && crypto.getRandomValues ) {
					var randomValues = new Uint32Array(1)
					
					crypto.getRandomValues(randomValues)
					
					return randomValues[0] % count
				} else {
					return Math.floor(Math.random() * Math.floor(count)) | 0
				}
			}
			
			function randomFrequencyElement(array) {
				var sum = array.reduce((s, e) => s + (e.frequency | 0), 0)
				
				if ( sum > 0 ) {
					var value = randomInteger(sum)
					var save = value
					
					for ( var element of array ) {
						if ( value < element.frequency ) {
							return element
						}
						
						value -= (element.frequency | 0)
					}
				}
				
				return array[randomInteger(array.length)]
			}
			
			function frequencyPrefix(string) {
				var index = string.indexOf(':')
				var frequency = 1
				
				if ( index > 0 ) {
					frequency = parseInt(string.slice(0, index))
					string = string.slice(index + 1)
					
					if ( isNaN(frequency) ) {
						frequency = 1
					}
				}
				
				return {'frequency':frequency, 'value':string}
			}
			
			function randomFrequencyPrefix(array) {
				return randomFrequencyElement(array.map(frequencyPrefix)).value
			}
			
			function randomDieRoll(sides, rolls) {
				var sum = 0
				
				while ( rolls --> 0 ) {
					sum += 1 + randomInteger(sides)
				}
				
				return sum
			}
			
			function randomDiceRoll(dice, quantity) {
				var roll = parseInt(dice.roll) || 1
				var sides = parseInt(dice.die) || 1
				var times = parseInt(dice.times) || 1
				var add = parseInt(dice.add) || 0
				
				if ( quantity > 1 ) {
					roll *= quantity
					add *= quantity
				}
				
				return randomDieRoll(sides, roll) * times + add
			}
			
			function randomQuantity(quantity) {
				return randomDiceRoll(quantity)
			}
			
			function lookupArmor(armor) {
				if ( Array.isArray(armor) ) {
					armor = randomFrequencyPrefix(armor)
				}
				
				var item = lookup.armors && lookup.armors[armor]
				
				return item && item.name || armor
			}
			
			function lookupWeapon(weapon) {
				if ( Array.isArray(weapon) ) {
					if ( weapon.length > 0 ) {
						weapon = randomFrequencyPrefix(weapon)
					} else {
						weapon = randomFrequencyElement(treasure.magic.weapons).weapon
					}
				}
				
				var item = lookup.weapons && lookup.weapons[weapon]
				
				return item && item.name || weapon
			}
			
			function lookupVariant(variant) {
				if ( Array.isArray(variant) ) {
					variant = randomFrequencyPrefix(variant)
				}
				
				return variant
			}
			
			function lookupMagicItem(entry) {
				if ( entry.item === 'armor' && entry.armor && entry.bonus > 0 && !entry.variant ) {
					return lookupArmor(entry.armor) + " +" + entry.bonus
				}
				
				var item = lookup.items[entry.item]
				var description = item && item.name || entry.item
				var quantity = item.quantity ? randomQuantity(item.quantity) : 0
				var variant = entry.variant || item.variant
				
				if ( entry.bonus ) { description += " +" + entry.bonus }
				
				if ( quantity > 0 ) {
					if ( variant && Array.isArray(variant) ) {
						var variants = []
						
						while ( quantity --> 0 ) {
							variants.push(lookupVariant(variant))
						}
						
						variants = coalesceArrayElements(variants)
						description += " (" + variants.join(", ") + ")"
					} else if ( item.unit ) {
						description += " (" + quantity + " " + item.unit + ")"
					} else {
						description += defaults.times + quantity
					}
				} else {
					if ( variant ) { description += " (" + lookupVariant(variant) + ")" }
				}
				
				
				if ( entry.armor ) { description += ", " + lookupArmor(entry.armor) }
				if ( entry.weapon ) { description += ", " + lookupWeapon(entry.weapon) }
				
				return description
			}
			
			function generateCoins(treasure, tables, quantity) {
				var descriptions = []
				var coins = treasure.coins
				var total = 0
				var sum = 0
				var table, value
				
				for ( var coin of coins ) {
					value = 0
					
					for ( table of tables ) {
						if ( coin.key && table[coin.key] ) {
							value += randomDiceRoll(table[coin.key], quantity)
						
						}
					}
					
					if ( value > 0 ) {
						sum += value * coin.cp
						total += value
						descriptions.push(value + coin.key)
					}
				}
				
				return {"sum":sum, "descriptions":descriptions, "total":total, "pounds":total / 50}
			}
			
			function generateValuables(treasure, entry, key) {
				var value = entry.value
				var names = treasure[key][value]
				var count = randomDiceRoll(entry)
				var name = names[randomInteger(names.length)]
				
				return {"sum":count * value * 100, "descriptions":[count + defaults.times + value + "gp " + name]}
			}
			
			function generateMagicItem(treasure, key) {
				if ( defaults.forceMagicItemTable ) {
					key = defaults.forceMagicItemTable
				}
				
				var prefix = defaults.includeMagicItemTable ? key.toUpperCase() + ": " : ""
				var table, item = null
				
				while ( key && treasure.magic[key] ) {
					item = randomFrequencyElement(treasure.magic[key])
					key = item.items
				}
				
				return item && (prefix + lookupMagicItem(item))
			}
			
			function generateMagicItems(treasure, entry, key) {
				var index, count = randomDiceRoll(entry)
				var items = []
				
				while ( count --> 0 ) {
					items.push(generateMagicItem(treasure, key))
				}
				
				return items
			}
			
			function valueSummary(sum, pounds) {
				if ( pounds > defaults.minimumPoundsToDisplayWeight ) {
					return "(Total " + (sum / 100) + "gp, Weighs " + (pounds > 4000 ? Math.floor(pounds / 20) / 100 + " tons" : Math.floor(pounds) + "lb") + ")"
				} else {
					return "(Total " + (sum / 100) + "gp)"
				}
			}
			
			function generateIndividual(treasure, individual, quantity) {
				var index, entry, entries = []
				
				for ( index = 0 ; index < quantity ; ++index ) {
					entries.push(randomFrequencyElement(individual.table))
				}
				
				var coins = generateCoins(treasure, entries, 1)
				
				if ( coins.pounds > defaults.minimumPoundsToDisplayWeight || coins.descriptions.length > 2 ) {
					coins.descriptions.push(valueSummary(coins.sum, coins.pounds))
				}
				
				return coins.descriptions
			}
			
			function generateRawHoard(treasure, hoard, quantity) {
				var valuableTables = ['gem', 'art']
				var magicTables = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
				var coins = generateCoins(treasure, [hoard.coins], quantity)
				var descriptions = []
				var index, entry, entries = []
				var valuables, items, key
				var sum = coins.sum
				
				for ( index = 0 ; index < quantity ; ++index ) {
					entries.push(randomFrequencyElement(hoard.table))
				}
				
				for ( entry of entries ) {
					for ( key of magicTables ) {
						if ( entry['magic_' + key] ) {
							items = generateMagicItems(treasure, entry['magic_' + key], key)
							
							descriptions.push.apply(descriptions, items)
						}
					}
				}
				
				descriptions = coalesceArrayElements(descriptions)
				descriptions.sort()
				
				for ( entry of entries ) {
					for ( key of valuableTables ) {
						if ( entry[key] ) {
							valuables = generateValuables(treasure, entry[key], key)
							sum += valuables.sum | 0
						
							descriptions.push.apply(descriptions, valuables.descriptions)
						}
					}
				}
				
				descriptions.push.apply(descriptions, coins.descriptions)
				descriptions.push(valueSummary(sum, coins.pounds))
				
				return descriptions
			}
			
			function generateColeHoard(treasure, hoard, quantity, singlePointsTotal) {
				var valuableTables = ['gem', 'art']
				var magicTables = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
				var coins = generateCoins(treasure, [hoard.coins], quantity)
				var descriptions = []
				var pointsLimit = 24, pointsDie = 6
				var index, entry, sum = coins.sum
				var valuables, points, die, key, prefix
				
				quantity = quantity > 0 ? quantity : 1
				
				for ( index = 0 ; index < quantity ; ++index ) {
					points = quantity - index
					
					if ( points < 1 || singlePointsTotal ) {
						points = randomDieRoll(pointsDie, Math.ceil(points * pointsLimit / pointsDie))
						index = quantity
					} else {
						points = randomDieRoll(pointsDie, Math.ceil(pointsLimit / pointsDie))
					}
					
					while ( points > 0 ) {
						entry = randomFrequencyElement(hoard.table)
						die = 0
						
						for ( key of magicTables ) {
							if ( entry['magic_' + key] ) {
								die = Math.max(die, entry['magic_' + key].die)
								descriptions.push(generateMagicItem(treasure, key))
							}
						}
						
						points -= pointsLimit / (die > 0 ? die : 4)
					}
				}
				
				descriptions = coalesceArrayElements(descriptions)
				descriptions.sort()
				
				for ( index = 0 ; index < quantity ; ++index ) {
					entry = randomFrequencyElement(hoard.table)
					
					for ( key of valuableTables ) {
						if ( entry[key] ) {
							valuables = generateValuables(treasure, entry[key], key)
							sum += valuables.sum | 0
						
							descriptions.push.apply(descriptions, valuables.descriptions)
						}
					}
				}
				
				descriptions.push.apply(descriptions, coins.descriptions)
				descriptions.push(valueSummary(sum, coins.pounds))
				
				return descriptions
			}
			
			function generateHoard(treasure, hoard, quantity) {
				if ( defaults.raw ) {
					return generateRawHoard(treasure, hoard, quantity)
				} else {
					return generateColeHoard(treasure, hoard, quantity, false)
				}
			}
			
			function generateRawParty(treasure, level, quantity) {
				var valuableTables = ['gem', 'art']
				var list = treasure['hoard']
				var count = list.length
				var table, items, hoard, tally, rolls
				var index, entry, descriptions, aggregate = []
				var coins, valuables, sum, key
				
				for ( index = 0 ; index < count && list[index].cr <= level ; ++index ) {
					descriptions = []
					hoard = list[index]
					table = hoard.party_items
					
					for ( items of table ) {
						rolls = quantity * items.quantity
						rolls = Math.floor(rolls) + (Math.random() < (rolls - Math.floor(rolls)) ? 1 : 0)
						
						for ( tally = 0 ; tally < rolls ; ++tally ) {
							descriptions.push(generateMagicItem(treasure, items.magic))
						}
					}
					
					descriptions = coalesceArrayElements(descriptions)
					descriptions.sort()
					
					rolls = hoard.party_hoards.reduce((s, v) => s + v, 0)
					rolls = Math.round(rolls * quantity)
					coins = generateCoins(treasure, [hoard.coins], rolls)
					sum = coins.sum
					
					for ( tally = 0 ; tally < rolls ; ++tally ) {
						entry = randomFrequencyElement(hoard.table)
						
						for ( key of valuableTables ) {
							if ( entry[key] ) {
								valuables = generateValuables(treasure, entry[key], key)
								sum += valuables.sum | 0
								
								descriptions.push.apply(descriptions, valuables.descriptions)
							}
						}
					}
					
					descriptions.push.apply(descriptions, coins.descriptions)
					descriptions.push(valueSummary(sum, coins.pounds))
					
					aggregate.push(descriptions)
				}
				
				aggregate.reverse()
				
				return aggregate.concat.apply([], aggregate)
			}
			
			function generateColeParty(treasure, level, quantity) {
				var list = treasure['hoard']
				var count = list.length
				var index, entry, aggregate = []
				var hoards = []
				var limit, range, rolls
				
				for ( index = 0 ; index < count ; ++index ) {
					entry = list[index]
					rolls = 0
					range = level - entry.cr + 1
					limit = entry.party_hoards.length
					
					if ( range > 0 ) {
						rolls = entry.party_hoards.slice(0, range).reduce((s, v) => s + v, 0)
					}
					
					if ( range > limit && index + 1 >= count ) {
						rolls += (range - limit) * entry.party_hoards[limit - 1]
					}
					
					hoards.push(rolls)
				}
				
				for ( index = 0 ; index < count && hoards[index] > 0 ; ++index ) {
					entry = list[index]
					rolls = hoards[index]
					aggregate.push(generateColeHoard(treasure, entry, quantity * rolls))
				}
				
				aggregate.reverse()
				
				return aggregate.concat.apply([], aggregate)
			}
			
			function generateParty(treasure, level, quantity) {
				if ( defaults.raw ) {
					return generateRawParty(treasure, level, quantity)
				} else {
					return generateColeParty(treasure, level, quantity)
				}
			}
			
			function generatePlayer(treasure, level, quantity) {
				return generateParty(treasure, level, quantity / 4)
			}
			
			function generateTreasure() {
				var treasure = window.treasure
				var form = _element('treasure-form')
				var kind = form.kind.value
				var challenge = form.challenge.value
				var quantity = form.quantity.value || 1
				var list = treasure[kind === 'individual' ? kind : 'hoard']
				var entry = list.filter(i => i.cr <= challenge).pop()
				var descriptions
				
				defaults.raw = form.raw.checked
				
				if ( kind === 'hoard' ) {
					if ( quantity > 1 && defaults.partition ) {
						descriptions = []
						
						while ( quantity --> 0 ) {
							descriptions.push.apply(descriptions, generateHoard(treasure, entry, 1))
							descriptions.push("")
						}
						
						descriptions.pop()
					} else {
						descriptions = generateHoard(treasure, entry, quantity)
					}
				} else if ( kind === 'party' ) {
					descriptions = generateParty(treasure, challenge, quantity)
				} else if ( kind === 'player' ) {
					descriptions = generatePlayer(treasure, challenge, quantity)
				} else {
					descriptions = generateIndividual(treasure, entry, quantity)
				}
				
				displayTreasure(treasure, descriptions)
			}
			
			function handleReroll(key, identifier) {
				var item = generateMagicItem(treasure, key.toLowerCase())
				
				_element(identifier).innerHTML = item.slice(1)
			}
			
			function displayTreasure(treasure, list) {
				var items
				
				if ( defaults.includeMagicItemTable ) {
					var key, identifier, item, index, count = list.length
					
					items = []
					
					for ( index = 0 ; index < count ; ++index ) {
						item = list[index]
						key = item.slice(0, 1)
						
						if ( item.slice(1, 2) === ':' && treasure.magic[key.toLowerCase()] ) {
							identifier = "item-" + (index + 1)
							item = "<span class='reroll' onclick='handleReroll(\"" + key + "\", \""+identifier+"\")'>" + key + "</span><span id='" + identifier + "'>" + item.slice(1) + "</span>"
						}
						
						items.push("<li>" + item + "</li>")
					}
				} else {
					items = list.map(i => "<li>" + i + "</li>")
				}
				
				var html = "<ul class='treasure'>" + items.join("") + "</ul>"
				
				_element('treasure-list').innerHTML = html
			}
			
			function inflateParameters(result, string, leading, separator) {
				if ( string.charAt(0) === leading ) { string = string.slice(1) }
				
				var part, parts = string.split(separator)
				var object = result || {}
				
				for ( part of parts ) {
					var equals = part.indexOf("=")
					var value = (equals < 0) ? true : decodeURIComponent(part.slice(equals + 1))
					var key = equals < 0 ? part : part.slice(0, equals)
					
					object[key] = value
				}
				
				return object
			}
			
			function applyParameters() {
				var hash = inflateParameters(null, location.hash, '#', '|')
				var object = inflateParameters(hash, location.search, '?', '&')
				var form = _element('treasure-form')
				var key, value
				
				value = object['k']
				if ( value ) {
					if ( value.startsWith('i') ) { form.kind.value = 'individual' }
					else if ( value.startsWith('play') ) { form.kind.value = 'player' }
					else if ( value.startsWith('p') ) { form.kind.value = 'party' }
					else { form.kind.value = 'hoard' }
				}
				
				value = object['c'] | 0
				if ( value > 0 ) { form.challenge.value = value }
				
				value = object['n'] | 0
				if ( value > 1 ) { form.quantity.value = value }
				
				value = object['w'] | 0
				if ( value > 1 ) { defaults.minimumPoundsToDisplayWeight = value }
				
				value = object['m']
				if ( value && treasure.magic[value] ) { defaults.forceMagicItemTable = value }
				
				value = object['d']
				if ( value ) { defaults.includeMagicItemTable = true }
				
				value = object['p']
				if ( value ) { defaults.partition = true }
				
				value = object['raw']
				if ( value ) { form.raw.checked = true }
			}
			
			function validateTreasure() {
				var magicTables = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'i-armor']
				var index, keys = treasure.items.map(i => i.key)
				var table, sum
				
				for ( table of treasure.hoard ) {
					sum = table.table.reduce((s, e) => s + e.frequency, 0)
					
					if ( sum != 100 ) {
						console.log("Incorrect frequency sum " + sum + " on individual table CR " + table.cr)
					}
				}
				
				for ( table of treasure.individual ) {
					sum = table.table.reduce((s, e) => s + e.frequency, 0)
					
					if ( sum != 100 ) {
						console.log("Incorrect frequency sum " + sum + " on hoard table CR " + table.cr)
					}
				}
				
				for ( table of magicTables ) {
					sum = treasure.magic[table].reduce((s, e) => s + e.frequency, 0)
					
					if ( sum != 100 && table.length == 1 ) {
						console.log("Incorrect frequency sum " + sum + " on magic table " + table)
					}
					
					for ( var entry of treasure.magic[table] ) {
						index = keys.indexOf(entry.item)
						if ( index >= 0 ) {
							keys.splice(index, 1)
						}
						
						if ( !lookup.items[entry.item] ) {
							console.log("Missing item " + entry.item)
						}
						if ( entry.armor && !lookup.armors[entry.armor] && !Array.isArray(entry.armor) ) {
							console.log("Missing armor " + entry.armor)
						}
						if ( entry.weapon ) {
							if ( Array.isArray(entry.weapon) ) {
								for ( weapon of entry.weapon ) {
									if ( !lookup.weapons[weapon.slice(weapon.indexOf(':') + 1)] ) {
										console.log("Missing weapon " + weapon)
									}
								}
							} else {
								if ( !lookup.weapons[entry.weapon] ) {
									console.log("Missing weapon " + entry.weapon)
								}
							}
						}
					}
				}
				
				for ( var key of keys ) {
					console.log("Unreferenced item " + key)
				}
			}
			
			function populateLookup() {
				var keys = ['armors', 'weapons', 'items']
				var valueByKey = new Object()
				
				for ( var key of keys ) {
					valueByKey[key] = new Object()
					
					for ( var value of treasure[key] ) { valueByKey[key][value.key] = value }
				}
				
				window.lookup = valueByKey
				
				validateTreasure()
			}
			
			function populatePage() {
				populateLookup()
				applyParameters()
				generateTreasure()
			}
		</script>
		
		<style>
			html {
				background: #EEE;
			}
			
			body {
				-webkit-font-smoothing: antialiased;
				-webkit-touch-callout: none;
				color: #555;
				background: #FFF;
				font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
				font-size: 14px;
				line-height: 1.75;
				padding: 2em;
				margin: 0 auto;
				max-width: 50em;
			}
			
			html { background-image: linear-gradient(270deg, rgb(230, 233, 233) 0%, rgb(216, 221, 221) 100%); }
			body { position:relative; box-shadow: 0 0 0.125em rgba(0, 0, 0, 0.06); }
			
			p.explanation { font-size:80%; color:#999; }
			span.reroll { color:#123; cursor:pointer; }
			
			.nose, .reroll {
				-webkit-touch-callout:none;
				-webkit-user-select:none;
				-moz-user-select:none;
				-ms-user-select:none;
				-o-user-select:none;
				user-select:none;
			}
		</style>
	</head>
	<body onload='populatePage()'>
		<h4>Treasure</h4>
		
		<form id='treasure-form' onsubmit="generateTreasure(); return false">
		<select name='kind' id='treasure-kind'>
			<option value="individual">Individual Treasure</option>
			<option value="hoard" selected>Treasure Hoard</option>
			<option value="party">Party Treasure</option>
			<option value="player">Player (&frac14; Party)</option>
		</select>
		<input name='challenge' id='treasure-challenge' type='number' value='4' min='0' max='30' />
		&times; <input type='number' name='quantity' value='1' min='1' max='99' id='treasure-quantity' />
		<input type='submit' value='Roll' />
		<input type='checkbox' name='raw' id='treasure-raw' /><label for='treasure-raw'> RaW</label>
		</form>
		
		<p id='treasure-list'></p>
		<table id='treasure'></table>
		
		<p class='explanation'>RaW rolls from the DMG treasure hoard tables, choosing all items from the same magic item table.  The Cole method uses the same tables in a slightly different way to mix items of different rarity.</p>
	</body>
</html>
